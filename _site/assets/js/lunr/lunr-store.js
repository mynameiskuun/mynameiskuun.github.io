var store = [{
        "title": "SQL 문제 풀이 - SELECT",
        "excerpt":"프로그래머스 SQL 코딩테스트 연습   서울에 위치한 식당 목록 출력하기     REST_INFO와 REST_REVIEW 테이블에서 서울에 위치한 식당들의 식당 ID, 식당 이름, 음식 종류, 즐겨찾기수, 주소, 리뷰 평균 점수를 조회하는 SQL문을 작성해주세요. 이때 리뷰 평균점수는 소수점 세 번째 자리에서 반올림 해주시고 결과는 평균점수를 기준으로 내림차순 정렬해주시고, 평균점수가 같다면 즐겨찾기수를 기준으로 내림차순 정렬해주세요.           문제 해결 중 학습한 내용          GROUP BY            GROUP BY는 주로 COUNT(), MAX(), MIN(), SUM(), AVG() 등의 집계 함수와 같이 사용된다.  GROUP BY 사용 시 SELECT 되는 모든 열은 반드시 집계 함수가 사용되거나, GROUP BY의 대상이어야 한다.   연산 순서는 SELECT - FROM - JOIN - WHERE - GROUP BY - HAVING 이며,  WHERE 절은 그룹핑 되기 전 칼럼에 대한 필터링, HAVING은 그룹핑 완료 후 결과셋의 필터링을 처리한다.            와일드카드            데이터 값에 특정 문자열이 포함된 레코드를 찾기 위해, 와일드 카드를 사용할 수 있으며, 이때 반드시 LIKE 연산자를 사용해야 한다. 하지만 와일드 카드 검색은 대체로 다른 검색보다 시간이 오래걸린다. 와일드카드로 시작하는 검색 패턴은 처리가 가장 느리다.            ON, WHERE의 차이점            두가지 모두 JOIN을 위한 조건절로 사용되지만, ON은 JOIN이 이루어 지기 전 필터링, WHERE는 JOIN 이후 필터링이 처리되는 차이가 있다.                    정답       SELECT     i.REST_ID,     i.REST_NAME,     i.FOOD_TYPE,     i.FAVORITES,     i.ADDRESS,     ROUND(AVG(r.REVIEW_SCORE), 2) as SCORE FROM     rest_info i JOIN     rest_review r ON     i.REST_ID = r.REST_ID WHERE     i.ADDRESS LIKE '서울%' GROUP BY     i.REST_NAME ORDER BY     SCORE DESC,     FAVORITES DESC           오답 포인트          JOIN이 아닌 LEFT JOIN 사용            LEFT JOIN 사용 시 리뷰가 한건도 작성되지 않은 식당 정보도 포함됨.          ","categories": ["coding-test"],
        "tags": ["SQL"],
        "url": "/coding-test/SQL-%EB%AC%B8%EC%A0%9C%ED%92%80%EC%9D%B4(1)/",
        "teaser": null
      },{
        "title": "SQL 문제 풀이 - SELECT",
        "excerpt":"프로그래머스 SQL 코딩테스트 연습   오프라인/온라인 판매 데이터 통합하기     ONLINE_SALE 테이블과 OFFLINE_SALE 테이블에서 2022년 3월의 오프라인/온라인 상품 판매 데이터의 판매 날짜, 상품ID, 유저ID, 판매량을 출력하는 SQL문을 작성해주세요. OFFLINE_SALE 테이블의 판매 데이터의 USER_ID 값은 NULL 로 표시해주세요. 결과는 판매일을 기준으로 오름차순 정렬해주시고 판매일이 같다면 상품 ID를 기준으로 오름차순, 상품ID까지 같다면 유저 ID를 기준으로 오름차순 정렬해주세요.           어려웠던 부분                      어떻게 두 테이블의 결과를 하나로 묶어서 반환할 것인가?          테이블을 묶는 과정에서, OFFLINE_SALE 테이블에 없는 USER_ID 값을 어떻게 NULL로 표현할 것인가?                       문제 해결 중 학습한 내용       1. Union / Union All      두개 이상의 SELECT 결과를 하나로 합쳐서 표현해야 할 때 사용된다.   출력하고자 하는 열의 갯수와 자료형이 서로 일치해야 한다.   이 과정에서 UNION은 중복되는 레코드를 모두 제거한다. 하지만 UNION ALL은 별도의 중복 제거 과정을 거치지 않는다. 이 때문에, 중복 제거 과정을 거치지 않는 UNION ALL이 1.5배 ~ 4배 가량의 성능 차이로 빠르게 처리된다.          사실 둘다 좋은 SQL 작성은 아니다. 나뉜 두가지의 테이블을 하나로 합쳐야 하는 경우가 있다면, 애초부터 분리 운영되야 할 이유가 없는 경우가 더 많다.        UNION을 사용하게 될 경우, 가급적 최소 칼럼만을 사용하고, UNION ALL을 사용하는것이 좋다.    2. 컬럼에 NULL 넣기      주로 UNION을 사용해서 서로다른 테이블 혹은 SELECT 문을 하나로 합칠때, 컬럼의 데이터 종류가 맞지 않거나 컬럼의 갯수를 맞추기 위하여 주로 사용하곤 한다. 위 SQL 문제에서는, 두 테이블을 UNION을 사용하여 합쳐야 했으나, OFFLINE_SALE 테이블에는 없는 USER_ID 컬럼도 포함해서 UNION을 해야 했기 때문에, OFFLINE_SALE 테이블의 USER_ID에 한해서 임의로 NULL을 넣어야 했다.          방법은? 그냥 SELECT NULL 하면 진짜로 NULL이 찍힌다.       3. WHERE 1=1 (번외)      WHERE 1=1 ? 말 그대로 ‘참’ 을 의미한다. 굳이 없어도 될듯 한데 사용하는 이유는?       1. 쿼리 디버깅 시, 주석 처리가 편하다.          SELECT *   FROM CUSTOMERS   WHERE 1=1   (1) AND IDX = #IDX   (2) AND CUSTOMER_ID LIKE ‘L%”;          쿼리 디버깅 시, (1), (2)의 주석처리 및 별도 테스트가 용이하다.         2. 동적 쿼리에서 다른 조건절을 추가하기 용이하다.          동적 쿼리에서는, 특정 조건에 따라 WHERE 구문의 AND 절이 통으로 추가되거나 삭제되곤 한다. 이 때, WHERE절 첫 시작부분 부터 동적으로 제외될 수 있다면 이후 조건절을 작성하기가 매우 까다로워 지기 때문에, WHERE 1=1 등 무조건 참인 조건절을 시작부분에 추가한다. 이 덕분에, 이후의 AND 조건절들은 생성여부에 상관없이 문법 오류를 일으키지 않는다.        myBatis를 사용한다면, 다음과 같은 형식으로 WHERE 1=1을 사용하지 않고도 편리하게 동적 쿼리를 작성할 수 있다.     &lt;where&gt;   &lt;if test=\"state != null\"&gt;      state = #{state}   &lt;/if&gt;   &lt;if test=\"title != null\"&gt;      AND title like #{title}   &lt;/if&gt;   &lt;if test=\"author != null and author.name != null\"&gt;      AND author_name like #{author.name}   &lt;/if&gt; &lt;/where&gt;       이 where절 안에서는, where절 시작이 AND 혹은 OR로 시작되면 자동으로 이를 생략 해 주는 기능이 있다.                 주의할 점             WHERE 1=1 사용으로 발생할 수 있는 문제점은 크게 다음과 같다.            실행 계획 수립이 늦어질 수 있다.                조건절에 따라 적절한 인덱스를 선택하는 것과 같은 최적화 작업을 수행하는 데이터베이스 엔진에게 혼동을 줄 수 있다.                  쿼리의 결과가 변경되지 않기 때문에, 쿼리 결과가 캐시에 저장 될 때, 다른 쿼리 결과와 구분이 어려워져 캐시 성능이 저하될 수 있다.            따라서 WHERE 1=1을 사용할 때에는, 적절한 인덱스를 사용하는 등의 최적화 작업을 수행하여 쿼리의 성능을 향상시켜야 한다. 하지만 WHERE 1=1이 직접적인 성능저하의 원인이 되는 경우는 많지 않기 때문에, 특별히 걱정하지 않아도 된다.      ","categories": ["coding-test"],
        "tags": ["SQL"],
        "url": "/coding-test/SQL-%EB%AC%B8%EC%A0%9C%ED%92%80%EC%9D%B4(2)/",
        "teaser": null
      },{
        "title": "알고리즘 문제풀이 - 가장 짧은 문자거리 찾기",
        "excerpt":"알고리즘 문제풀이 연습 - 1        어려웠던 부분   1. 구현 방법의 잘못된 접근      while문 속에서 lt, rt 값을 사용하여 왼쪽과 오른쪽을 한번에 탐색하려고 시도함.   문자열에서 비교 대상 문자가 속해있는 index값을 전부 저장해 두고, 문자열을 쪼개서 반복문을 돌며 index - 문자 값 중 가장 작은값을 return하려 시도.      문제를 단계별로 나누어 해결하기 보다, 한번에 해결하려고 하다 보니 위와 같은 어렵고 복잡한 구현 방법을 생각하게 되었음.       강의에서 제시한 방법으로 구현 할 시, 문자열의 length * 2 만큼만 반복하면 해결이 가능함. 하지만 위의 방법으로 구현 시, !string.length() 만큼 반복 횟수가 늘어남.    문제 해결 중 학습한 내용      문제 접근 방법   int[] answer = new int[str.length()];         int index = 1000;          for(int i = 0; i &lt; str.length(); i++) {             if(str.charAt(i) == c) {                 index = 0;                 answer[i] = index;             } else {                 index++;                 answer[i] = index;             }         }      문자열의 index를 왼쪽부터 조회하며, 해당 index의 왼편에서 비교대상 문자를 찾아 얼마나 떨어져 있는지 그 값을 저장한다. (오른쪽에 있을 경우는 생각하지 않는다.)    for(int j = str.length() - 1; j &gt;= 0; j--) {             if(str.charAt(j) == c) {                 index = 0;             } else {                 index++;                 answer[j] = Math.min(answer[j], index);             }         }      문자열의 index를 오른쪽부터 왼쪽으로 조회한다. 이 과정에서, 앞서 조회했던 값보다 위에서 조회한 절대값이 더 작을 경우(오른편에 있는 문자로부터의 절대값이 더 작을경우) 해당 index를 저장한다.   ","categories": ["coding-test"],
        "tags": ["Algorithm"],
        "url": "/coding-test/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%AC%B8%EC%A0%9C%ED%92%80%EC%9D%B4/",
        "teaser": null
      },{
        "title": "알고리즘 문제풀이 - 피보나치 수열",
        "excerpt":"알고리즘 문제풀이 연습 - 2        제출한 답안   public int[] solution(int count) {          int[] answer = new int[count];         answer[0] = 1;         answer[1] = 1;          for(int i = 2; i&lt;count; i++) {             answer[i] = answer[i-2] + answer[i-1];         }          return answer;     }   문제 해결 중 학습한 부분.   재귀함수           재귀란?              컴퓨터 과학에서, 자신을 정의할 때 자기 자신을 재참조 하는 방법.                 재귀함수란?             재귀의 설명 그대로, 함수에서 자기 자신을 다시 호출해 작업을 수행하는 방식. 주로 반복문을 구현할 때 사용한다.              재귀함수를 이용한 피보나치 수열 구현   public int solution(int count) {      if(count &lt;= 1) {         return 1;     }     return solution(i-2) + solution(i-1); }     재귀함수의 장단점   장점      가독성이 향상된다.   변수 사용을 줄여줌으로서, 변경 가능성(mutable state)을 최소화 시켜 프로그램의 안정성을 향상시킨다.   단점      매개변수, 지역변수, 리턴 값, 함수 종료 후 복귀지점이 스택 메모리에 저장되기 때문에, 메모리 사용량이 높다.   그렇기 때문에 일반적으로 반복문 보다 성능이 낮다.     재귀함수 단점 보완을 위한 방법   메모이제이션      재귀함수의 단점을 보완하기 위한 방법으로 값비싼 함수 호출의 결과를 캐싱하고, 동일한 입력이 발생할 때 함수를 호출하지 않고 캐싱된 결과를 반환하는 기술.      메모이제이션을 사용해 구현한 피보나치 수열   public static void int[] memo;  public int solution(int count) {     if(memo[count] &gt; 0) {         return memo[count];     }     if(count &lt;= 1) {         return 1;     }     return memo[i] = solution(count - 1) + solution(count - 2); }      기존의 로직이라면, 캐싱된 값이 없기 때문에 콜스택에 count만큼 지역변수, 매개변수, 반환주소 등이 쌓이고, count의 마지막 부분에 가서야 모든 작업이 수행됨.   메모이제이션을 사용할 경우, static 변수에 한번 연산된 값을 저장하게 됨. 이 경우, 한번 연산된 값은 이후 재귀함수를 통해 재연산이 불필요.      핵심 : 한번 연산된 값을 저장해서, 이후 동일 작업이 호출될 때 재연산을 하는게 아닌 저장된 값을 반환한다.   ","categories": ["coding-test"],
        "tags": ["Algorithm"],
        "url": "/coding-test/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%AC%B8%EC%A0%9C%ED%92%80%EC%9D%B4(2)/",
        "teaser": null
      },{
        "title": "알고리즘 문제풀이 - 소수의 판별",
        "excerpt":"알고리즘 문제풀이 연습 - 3        제출한 답안   public class Main{      public int solution(int count) {          int answer = 0;         int[] array = new int[count+1];         array[0] = 1;         array[1] = 1;          for(int i=2; i&lt;=count; i++) {             for(int j=2; j&lt;=i; j++) {                 if( // 소수 판별 ) {                     answer++;                     // 판별된 소수 배수 val 1 처리                 }             }             return answer;         }     }     //main method 생략 }   어려웠던 점      소수 판별 어떻게?            2 ~ count까지의 수를 반복문을 통해 소수 여부를 판별하려 했음. 하지만 위의 로직대로라면, 2와 3은 소수이지만 내부 반복문에서 2와 3으로 나눠지기 때문에 나머지가 0으로 되어 소수가 아닌것으로 처리되는 이슈. (사전처리 3까지 하고, i = 4로 설정?)           모범 답안   public class Main {    public int solution(int count) {      int answer = 0;     int[] array = new int[count+1];      for(int i=2; i&lt;=count; i++) {       if(array[i]==0){         answer++;         for(int j=i; j&lt;=count; j=j+i) {          array[j]=1;         }       }     }       return answer;   }      //main method 생략  }   주목할 포인트      2, 3의 처리방법            int형 배열 생성 시 기본값은 0. 2부터 반복문을 돌리고, 바로 value = 0 검사.       2, 3은 value 0이기 때문에 소수 처리 가능. 또한 배수 처리도 가능.       소수 판별 로직을 하나하나 작성하지 않아도, 2, 3의 사전 처리 때문에 자연스럽게 배수처리가 가능.           심화      위의 문제에서는 소수의 갯수만 출력하지만, 실제로 소수 그 자체를 출력하는 문제로 변형된다면?   function isPrime(int num) {   if(num == 1)     return false;   for(int i=2; i&lt;num; i++) {     if(num % i == 0) {       return false;     }   }   return true; }  if(isPrime(int num)) {   System.out.println(num); }      2 ~ n 까지의 숫자 중 어느것도 약수가 아닐때, (1과 자기 자신이 약수일 때) 해당 수는 소수가 된다.   ","categories": ["coding-test"],
        "tags": ["Algorithm"],
        "url": "/coding-test/%EC%97%90%EB%9D%BC%ED%86%A0%EC%8A%A4%ED%85%8C%EB%84%A4%EC%8A%A4%EC%9D%98_%EC%B2%B4/",
        "teaser": null
      },{
        "title": "알고리즘 문제풀이 - 소수 뒤집기",
        "excerpt":"알고리즘 문제풀이 연습 - 4        제출한 답안    public boolean isPrime(int num) {          if(num==1) return false;         for(int i=2; i&lt;num; i++) {              if(num % i == 0) {                  return false;              }         }         return true;     }      public List&lt;Integer&gt; solution(int count, int[] input) {          List&lt;Integer&gt; answer = new ArrayList&lt;&gt;();          for(int i=0; i&lt;count; i++) {             int tmp = input[i];             int res = 0;             while(tmp&gt;0) {                 int t = tmp%10;                 res = res * 10 + t;                 tmp = tmp/10;             }             if(isPrime(res)) {                 answer.add(res);             }         }         return answer;     }   어려웠던 점      숫자를 어떻게 뒤집을 것인가?            개인적으로는 입력받은 수를 StringBuilder의 reverse() 메소드로 뒤집을 생각이었음.       단순히 문자열을 뒤집는것 보다는, 위의 방법처럼 나머지와 몫을 이용해 수학적으로 접근하기.              t : %10 연산을 통해 가장 끝자리 수(나머지)를 추출하기 위한 변수.  res : 뒤집은 문자열을 저장하기 위한 변수. t의 값이 res * 10을 통해 자릿수를 형성함.   tmp : /10 연산을 통해 자릿수를 줄여나감. 반복문의 종료시점을 생성.   ","categories": ["coding-test"],
        "tags": ["Algorithm"],
        "url": "/coding-test/%EC%86%8C%EC%88%98-%EB%92%A4%EC%A7%91%EA%B8%B0/",
        "teaser": null
      },{
        "title": "알고리즘 문제풀이 - 격자판 최대합 구하기",
        "excerpt":"알고리즘 문제풀이 연습 - 5      제출한 답안   public class CodingTestApplication {      public int solution(int count, int[][] inputArray) {          int temp = 0;         int answer = 0;          for(int i=0; i&lt;count; i++) {             for(int j=0; j&lt;count; j++) {                 temp += inputArray[i][j];             }             if(temp &gt; answer) answer = temp;             temp = 0;              for(int k=0; k&lt;count; k++) {                 temp += inputArray[k][i];             }             if(temp &gt; answer) answer = temp;             temp = 0;         }          for(int i=0; i&lt;count; i++) {             for (int j = 0; j &lt; count; j++) {                 if (i == j) {                     temp += inputArray[i][j];                 }             }         }          if(temp &gt; answer) answer = temp;         temp = 0;          for(int i=0; i&lt;count; i++) {             for(int k=0; k&lt;count; k++) {                 if(i+k == count-1) {                     temp += inputArray[i][k];                 }             }         }         if(temp &gt; answer) answer = temp;          return answer;     }      public static void main(String[] args){         CodingTestApplication main = new CodingTestApplication();         Scanner in = new Scanner(System.in);          int count = in.nextInt();         int[][] inputArray = new int[count][count];          for(int i=0; i&lt;count; i++) {             for(int j=0; j&lt;count; j++) {                 inputArray[i][j] = in.nextInt();             }         }          System.out.println(main.solution(count, inputArray));     } }   개선점      문제의 난이도는 평이했으나, 코드를 좀더 간결하게 작성할 수 있었음.   개선점 1      가로합, 세로합 연산 로직 통합    TO-BE  for(int i=0; i&lt;count; i++) {     sum1 = sum2 = 0;     for(int j=0; j&lt;count; j++) {         sum1 += array[i][j];         sum2 += array[j][i];     }     answer = Math.MAX(answer, sum1);     answer = Math.MAX(answer, sum2); }   개선점 2      대각선 연산 로직 통합, 간결화    TO-BE  for(int i=0; i&lt;count; i++) {     sum1 += array[i][i];     sum2 += array[i][count-i-1]; }  ","categories": ["coding-test"],
        "tags": ["Algorithm"],
        "url": "/coding-test/%EA%B2%A9%EC%9E%90%ED%8C%90-%EC%B5%9C%EB%8C%80%ED%95%A9-%EA%B5%AC%ED%95%98%EA%B8%B0/",
        "teaser": null
      },{
        "title": "알고리즘 문제풀이 - 임시반장 정하기",
        "excerpt":"알고리즘 문제풀이 연습 - 6       제출한 답안   int answer = 0; int max = Integer.MIN_VALUE;  for(int i=0; i&lt;count; i++) { // 비교 기준 학생   int cnt = 0;   for(int j=0; j&lt;count; j++) { // 비교 대상 학생     for(int k=0; k&lt;5; k++) { // 학년       if(inputArray[i][k] == inputArray[j][k]) {         cnt++;         break;       }     }   }    if(cnt &gt; max) {     max = cnt;     answer = i;   } }   어려웠던 점           break              두 학생을 비교해서 같은반으로 판별된 즉시 반복문을 중지하지 않으면, 다른 학년에서 같은 반으로 판별될 경우 cnt가 1번 더 증가하게됨.                임시반장 후보가 여러명일 때, 가장 작은 번호 추리기             HashSet을 사용하여 중복을 제거하려 했으나 아래의 방법으로 간단하게 해결 가능.           if(cnt &gt; max) {   max = cnt; // 동일 cnt일 경우 가장 먼저 등록된 번호(가장 작은 번호)   answer = i; //index }  ","categories": ["coding-test"],
        "tags": ["Algorithm"],
        "url": "/coding-test/%EC%9E%84%EC%8B%9C%EB%B0%98%EC%9E%A5-%EC%A0%95%ED%95%98%EA%B8%B0/",
        "teaser": null
      },{
        "title": "실용적인 자바스크립트 - Basic",
        "excerpt":"폴리필(Polyfill)      해당 기능을 지원할 수 없거나, 호환성 문제로 인해 같은 기능이 다르게 실행될 때, 기능을 사용할 수 있도록 대체 구현을 하는 코드, 또는 라이브러리를 말한다.   Promise      자바스크립트의 비동기 객체 (Promise)를 한글로 사용하면서 혼용 하고 있음.   Fetch      자바스크립트의 비동기 통신 기능. 상기 Promise를 보다 쉽게 사용할 수 있도록 제공되는 프로미스의 Wrapper 기능.   동기(Sync) 와 비동기(Async)      동기는 코드가 순차적으로 실행되는것. 비동기는 앞쪽에 나오는 코드가 나중에 실행될 수 있는것. JS는 Promise와 같은 비동기 내장 객체를 지원한다.   스코프(Scope)      변수, 또는 코드가 영향을 미치는범위.   전역(Global), 함수(Function), 블록(Block), 로컬 스코프(Local Scope)      var는 전역과 함수 스코프를 지원하며, let, const는 전역과 블록 스코프를 지원한다.   함수 스코프는 함수 안에서만 접근이 가능한 지역변수가 되며, 블록 스코프는 블록 안에서만 접근이 가능하다.   let, const는 보다 정밀한 스코프 제어가 가능하고, 덕분에 리소스 낭비가 적다.   로컬 스코프는 전역이 아닌 함수, 블록 스코프를 말한다.   순회(Traversal)와 순환(Rotation)      JS의 순회란 방문해야 할 지점을 한번씩 방문하고 종료하는것. (ex. DOM 탐색 등)   순환이란 순회를 계속 반복하는것.   호이스팅(Hoisting)      변수와 함수 선언을 포함한 모든 선언을 스코프 최상단으로 끌어올려 스코프 안의 모든 코드에서 선언 정보에 접근이 가능하도록 하는 JS의 주요 기능.   var, let, const, function, class와 같은 선언이 호이스팅 대상.      호이스팅 예시와 호이스팅 과정    a = 0; var a = 10; console.log(a);  // 1. var a = undefined; // 2. a = 0; // 3. a = 10;   생성자 함수(Constructor Function)      반드시 “new” 연산자를 사용해 호출하며, 함수 이름 첫글자는 대문자로 시작.   생성자 함수와 일반 함수 사이에 기술적인 차이는 없다.   “new” 연산자를 써서 함수를 실행하면 아래와 같은 알고리즘이 동작한다.            빈 객체를 만들어 this에 할당합니다.       함수 본문을 실행합니다. this에 새로운 프로퍼티를 추가해 this를 수정합니다.       this를 반환한다.           function Cellphone(brand, price) {   this.brand = brand;   this.price = price; }  var iPhone = new Cellphone(\"apple\", 12000000); var galaxy = new Cellphone(\"samsung\", 12000000);  //  var iphone = {   brand: \"apple\",   price: 12000000, };  var galaxy = {   brand: \"samsung\",   price: 12000000, };   제너레이터 함수(Generator function)      생성자 함수와 혼동하기 쉽지만, 전혀 다름.   함수를 여러번 반복하며 순차적으로 반복적인 값을 얻을 수 있는 특별한 함수.   function* 혹은 함수이름앞에 *를 붙임. 보통 전자의 경우를 많이 사용함.   function* generator() {   yield 1;   yield 2;   yield 3;   return 4; }  let init = generator(); let one = init.next(); let two = init.next();  console.log(one); // 1 console.log(tow); // 2   클로저 함수(Closure function)      실행 시점, 또는 호출 시점의 렉시컬 환경(Lexical Environment)을 호출된 함수에서 기억하는 것을 클로저라고 한다.   렉시컬 환경이란, 현재 실행 context의 스코프에 있는 선언 정보와 값을 말한다.   &lt;button id=\"btn1\"&gt;버튼1&lt;/button&gt; &lt;button id=\"btn2\"&gt;버튼2&lt;/button&gt; &lt;button id=\"btn3\"&gt;버튼3&lt;/button&gt;  &lt;script&gt;   function count() {     var cnt = 0;     return {       plusCnt: function () {         cnt++;         console.log(cnt);       },     };   }    var countIIFE = (function () {     var cnt = 0;     return {       function() {         cnt++;         console.log(cnt);       },     };   })();    let count1 = new count();   let count2 = new count();   let count3 = countIIFE;    document.getElementById(\"btn1\").addEventListener(\"click\", count1.plusCnt);   document.getElementById(\"btn2\").addEventListener(\"click\", count2.plusCnt);   document.getElementById(\"btn3\").addEventListener(\"click\", count3); &lt;/script&gt;   클로저 기초   function outerFunc(name) {   let saying = name + \"안녕!\";   return function () {     return saying;   }; }  let closure1 = outerFunc(\"라이언\"); let closure2 = outerFunc(\"콘\");  console.log(closure1); // 라이언 안녕! console.log(closure2); // 콘 안녕!      outerFunc() 함수는 익명 함수를 반환하고 종료되며, 로컬변수 saying도 사라져야 한다.   하지만 closure1, closure2를 실행하면 이미 종료된 부모함수 outerFunc의 saying 변수에 접근 가능.   자식 함수에 해당하는 익명 함수가 부모 함수인 outerFunc() 함수의 실행 환경에 속한 saying 변수에 부모 함수 종료 후 접근할 수 있는것을 클로저 라고 하며, 익명 함수는 클로저 함수가 된다.   var, let, const의 차이                  선언자       중복선언       재할당       초기값       스코프                       var       가능       가능       undefined       함수                 let       불가능       가능       undefined       블록                 const       불가능       불가능       불가능       블록           절대값, 숫자의 부호를 얻기      Math.abs() -&gt; 부호 없는 양의 숫자 값을 반환. (절대값)   Math.sign() -&gt; 숫자의 부호를 알려줌. 1, 0, -1, NaN 중 1개 반환   true/false의 판단      false, null, undefined, ‘’, 0, NaN 모두 false로 판단.   if (data) {   console.log(data); }   null, undefined, 0의 차이      JS에서 값이 할당되지 않은것을 표현하는 방법은 2가지.            Null. 변수가 빈 값으로 초기화 된 상태.                    사용자가 명시적으로 변수에 대입 하는 경우 외에는 발생하지 않음.                       undefined. 사용자에 의해 변수에 값이 대입되지 않은 초기 상태의 변수.                    선언은 되었지만 초기화는 되지 않은 상태.           ex) let a;                        이와 관련해서, 함수 정의 시 불필요하게 많은 파라미터를 정의하는 것은 굉장히 좋지 않은 결과를 낳을 수 있음.                                       인자(Argument)와 파라미터(Parameter)의 차이      파라미터는 함수 정의 시 나열하는 변수명. 인자는 함수를 호출할 때 전달하는 실제 값.   객체(Object)      JS의 객체는 다양한 종류의 데이터들을 하나의 저장소에 담아 접근 및 관리하기 위해 사용.   var example = { company: \"uber\", depart: \"dev\", floor: 2 };      함수 자체를 객체에 저장할 수도 있음.   var example = {     var say = 'Hello!';     sayHello : function() {         console.log(say);     } }      컨벤션            key, value 사이에 공백을 하나 둔다.       객체 요소 구분자 쉼표 뒤에는 공백을 하나 둔다.       문자열 값 표현은 쌍따옴표를 사용하는것을 권장한다.           하나의 객체 안에는 하나의 키만 존재. but 하위 객체에 중복 key 선언 가능.   var example = { company: \"uber\", depart: \"dev\", depart: \"uid\" }; // error var example1 = { company: \"uber\", depart: \"dev\", person: { depart: \"uid\" } };   숫자를 문자열로 바꾸기      숫자 앞, 뒤에 빈 문자열 ‘‘을 + 연산자로 더해주면 숫자가 문자로 자동캐스팅 됨.   var str = 1 + \"\";   숫자 구분자 허용   var num = 1_000_000_000; // equals 1000000000   객체 유효성 체크 - 옵셔널 체이닝 연산자 ‘?’   var obj = {   company: {     name : 'the uber creative',     addr : 'nonhyeon',   }   depart: \"dev\", };  if(obj.company &amp;&amp; obj.company.name) {} // if(obj.company?.name) {} //   TDZ(Temporary Dead Zone)      임시 사각 지대. 호이스팅 된 변수, 함수 선언 정보 중 초기화 안된것들을 따로 저장해두는 분리된 메모리 영역.   렉시컬 환경 : 현재 실행중인 코드의 스코프 안에 선언된 변수, 함수정보와 값을 보관하는 메모리 영역   환경 레코드 : 현재 실행중인 코드 행의 스코프 안에 선언된 변수와 함수의 실행 환경 정보를 저장한 곳   함수 선언과 함수 표현의 호이스팅      아래 두 방법 모두 표준 JS 함수 정의 방법.   var a = function () {   console.log(\"example1\"); }; // 함수 표현  function b() {   conosle.log(\"exmaple2\"); } // 함수 선언      아래의 a()는 error 발생, b()는 정상작동 이유   a(); var a = function a() {   console.log(\"a\"); };  b(); function b() {   console.log(\"b\"); }      호이스팅 순서 때문.    var a = undefined; // 1. 변수 호이스팅 function b() {   console.log(\"b\"); // 2. 함수 호이스팅 } a(); // 3. 함수 호출 - error a = function a() {   console.log(\"a\"); // 4. 함수 정의 };   가비지 콜렉션(Garbage Collection)      메모리 관리 방식으로, 할당 후 사용되지 않는 메모리 공간을 일정 주기로 검사해서 회수하는 메모리 관리 방식.   더이상 변수에 의해 참조되지 않는 메모리 영역을 해제하는 방식으로 GC 작동.   debugger 키워드로 디버깅 시작      debugger 키워드를 코드 특정 위치에 삽입하면, 브라우저는 코드 실행을 해당 위치에서 잠시 멈추고 내장 디버거를 활성화 시킴.   let a = 100; let b = 200; let c = a + b; console.log(\"c=\", c);  debugger;  let d = a - b; console.log(\"d=\", d);  ","categories": ["book-study"],
        "tags": ["practical-js"],
        "url": "/book-study/Practical_js_basic/",
        "teaser": null
      },{
        "title": "실용적인 자바스크립트 - Function",
        "excerpt":"Rest Parameter(나머지 파라미터)      함수의 마지막 파라미터에 마침표 3개 (…)를 붙여 사실상 무한대의 파라미터를 사용할 수 있게 합니다.   function example(a, b, ....C) =&gt; {  console.log(a,b,C) }      위의 경우, C 가변인자는 무한대의 파라미터를 받을 수 있기 때문에 배열로 출력 됩니다.     Arrow Function(화살표 함수)      자바의 람다 표현식과 유사한 것으로, 예시를 통해 쉽게 이해할 수 있습니다.   function(a,b) {     return a + b; }  화살표 함수 적용  var example = (a,b) =&gt; {     return a + b; }    화살표 함수의 주요 특징      함수 안에 super, this 바인딩이 없음.   new 키워드 생성자를 사용할 수 있음.   블록 스코프를 사용.      화살표 함수 사용 시 유의사항       =&gt; 화살표는 항상 변수 선언부와 동일한 row에 위치해야 합니다.     일급 함수, 고차 함수      일급 함수란, 다른 함수의 매개변수로 삽입되거나 return의 직접적인 대상이 될 수 있는 함수를 말합니다.      변수의 스코프와 스코프 체인      스코프(scope)란 ? 현재 실행 코드가 접근할 수 있는 선언되 변수의 범위를 말합니다. 반대로 말하면 변수가 영향을 미치는 코드의 범위입니다.       자바스크립트의 3개의 스코프 타입은 각각 다른 스코프를 사용합니다.                  타입       스코프                       var       함수 스코프                 let       블록 스코프                 const       블록 스코프              함수 스코프 체인의 대표적인 예시   ```js var a = 1; var b = 5; function outerFunc() {   function innerFunc() {     a = b;   }   console.log(a); //1   a = 3;   b = 4;   innerFunc();   console.log(a); //4   var b = 2; } outerFunc(); console.log(a, b); //4,5   ### 함수 선언과 함수 표현  - 함수 선언 예시  ```js function example(a, b) {   console.log(a);   console.log(b); }      함수 표현 예시   let example = function funcName() {   return \"example\"; };     함수 표현과 함수 선언의 착각   let a = function nameFunc() {   console.log(\"nameFunc!\"); };      위의 경우는 함수 표현입니다.       함수 선언 몸체에 함수 이름이 있어도(nameFunc()) 변수에 대입을 하면(a) 함수 표현으로 선언됩니다.   즉, nameFunc()은 함수가 아니기 때문에 사용할 수 없고, 함수 표현 변수명으로 호출해야(a()) 함수가 실행됩니다.     함수 표현과 클로저      호이스팅이 지원되는 함수 선언을 사용하는것이 언뜻 보면 더 좋아보이지만, 이로 인해 여러개의 함수들이 호이스팅 되면 함수의 스코프 이슈를 피하기가 함들어집니다.   이와 더불어 함수 표현을 사용하는 이유는 함수 표현이 클로저를 지원하기 때문입니다.   var buttons = document.querySelectorAll(\".button\");  let i; for(i=0; &gt;buttons.length;, i++) {     buttons[i].onclick = (e) =&gt; {console.log(\"index\" + i)}; }      위의 코드에서, i의 값에 따라 각각 1,2,3이 출력되야 할것 같지만, 루프문이 모두 실행된 후의 값인 i=3으로 모두 출력됩니다.   버튼 클릭 시, 각각의 i를 출력시키려면 아래의 함수 표현(클로저 특성을 지닌)을 사용해야 합니다.   var buttons = document.querySelectorAll('.button');  let clickHandler = (index) =&gt; {     return =&gt; {         console.log(\"index : \" + index);     } }  let i; for(i = 0; i &lt; buttons.length; i++) {     button[i].onclick = clickHandler(i); }   인터페이스 함수      자바스크립트의 객체 작성 기법중 하나.   한 개 이상의 함수를 함수로 다시 감싸서 객체, 정확히는 객체 리터럴을 반환하는 래퍼(Wrapper) 함수의 역할을 하는 함수를 말합니다.   return으로 함수 안에 정의한 함수들의 이름을 담은 객체 리터럴을 반환한다.   function math(a, b) {   function plus() {     return a + b;   }   function minus() {     return a - b;   }   function multiple() {     return a * b;   }   function divide() {     return a / b;   }    return { plus, minus, multiple, divide }; }  const math = math(100, 50); console.log(math.plus()); // 150 console.log(math.minus()); // 50   커링(Currying) 함수      단일 호출로 처리하는 여러 파라미터를 가진 함수를 단일 파라미터를 사용하는 중첩 함수로 분리해서 사용하는 기법.   function add(a, b) {   return a + b; } add(1, 2);      Currying ver    function add(a) {   return function (b) {     return a + b;   }; }  add(1)(2);           부분 실행하는 단계를 분리 해 코드를 나눌 수 있지만, 파라미터 개수가 많고 중첩이 깊어지면 콜 스택 유지에 메모리를 더 사용하여 실행 속도 측면에서 불리해짐. 또한 중첩이 깊어지면 가독성 하락.            화살표 함수를 이용해 짧은 코드로도 작성 가능.       sum = (num1) =&gt; (num2) =&gt; (num3) =&gt; num1 + num2 + num3;   재귀 커링   function sum(a) {   return function (b) {     if (b === undefined) {       return a;     } else {       return sum(a + b);     }   }; }  console.log(sum(1)()); // 1 console.log(sum(1)(2)()); // 3      마지막 고차함수를 즉시실행 시키기 위해 빈 괄호를 넣으며, 재귀 커링 함수는 반드시 이렇게 구현해야 함.   믹스인 함수      단일 객체 상속의 한계를 넘어, 여러 객체에서 메소드나 속성을 상속받을 수 있게 하는 함수.   객체의 메소드, 속성을 모두 대상 객체로 복사 하며, 이름이 중복되면 값을 덮어씀.   jQuery의 $.extend 메소드와 유사한 기능.   function mixin(sourceObj, targetObj) {   return Object.assign(sourceObj, targetObj); }  var a = { name: \"sam\", age: 20 }; var b = { age: 21, addr: \"seoul\" };  var c = mixin(a, b); console.log(c); // {name : \"sam\", age : 21, addr : \"seoul\"};   디바운스 함수      디바운싱 이란, 동일 함수의 잦은 반복 실행을 차단하고 마지막 호출한 것만 실행되도록 하는 코딩 패턴.            검색어 입력 시, 매 키보드 입력 마다 api 호출이 된다면?            function debounceFunc(callback, delay=100) {   let timer;    return function() { // 디바운스 함수     if(timer) clearTimeout(timer);     timer = setTimeout{callback, delay}   } }  function runner() { // 콜백 함수   console.log(new Date()); }  let df = debounceFunc(runner, 1000);  ","categories": ["book-study"],
        "tags": ["practical-js"],
        "url": "/book-study/Practical_js_function/",
        "teaser": null
      },{
        "title": "JavaScript Deepdive - this",
        "excerpt":"this 키워드      자신이 속한 객체 또는 자신이 생성할 인스턴스를 가리키는 특수한 식별자를 this라고 하며, 이는 인스턴스 식별자를 알 수 없을 때 객체 내부의 프로퍼티와 메소드를 참조하기 위해서 만들어졌다.   객체 리터럴 방식      아래와 같은 객체 리터럴 방식의 객체에서는 getDiameter() 메서드가 속한 circle를 가리키는 식별자를 재귀적으로 참조할 수 있다.   const circle = {     radius = 5;      getDiameter() {         return 2 * circle.radius;     } };  console.log(circle.getDiameter()); // 10      하지만 자기 자신이 속한 객체를 재귀적으로 참조하는 방식은 권장되지 않는다.   생성자 함수 방식   function Circle(radius) {     // 이 시점에는 생성자 함수 자신이 생성할 인스턴스를 가리키는 식별자를 알 수 없다.     ???.radius = radius; }  Circle.prototype.getDIameter = function() {     // 마찬가지로 식별자를 알 수 없다.     return 2 * ????.radius; }  // 생성자 함수로 인스턴스를 생성하려면 먼저 생성자 함수를 정의해야 한다. const circle = new Circle(5);      생성자 함수를 통해 인스턴스를 생성하려면, 먼저 생성자 함수가 존재해야 한다.        하지만 이 생성자 함수에서 프로퍼티, 메서드 추가를 위해서는 자신이 생성할 인스턴스를 참조할 수 있어야 한다.            이 모순을 해결하기 위해 this라는 특수한 식별자를 제공하여, 생성자 함수 내부에서 인스턴스를 생성하기 전에 인스턴스를 참조할 수 있다.       단, this가 가리키는 값, this 바인딩은 함수 호출 방식에 의해 동적으로 결정된다.   console.log(this); // this : window  function ex() {   console.log(this); // this : window }  const person = {   name: \"Lee\",   getName() {     console.log(this); // this : {name: \"lee\", getName: f}     return this.name;   }, };  function Person(name) {   this.name = name;   console.log(this); // this : Person {name: \"lee\"} }  const me = new Person(\"lee\");      이 this는 객체의 프로퍼티나 메서드를 참조하기 위한 자기 참조 변수이므로, 일반적으로 객체의 메서드 내부 또는 생성자 함수 내부에서만 의미가 있다.   함수 호출 방식과 this 바인딩      this 바인딩은 함수 호출 방식, 즉 함수가 어떻게 호출되었는지에 따라 동적으로 결정된다.   렉시컬 스코프와 this 바인딩은 결정 시기가 다르다.            렉시컬 스코프 : 함수의 상위 스코프를 결정하는 방식. 함수 정의가 평가되어 함수 객체가 생성되는 시점에 상위 스코프를 결정한다.       this 바인딩 : 함수 호출 시점에 결정된다.           const foo = function () {   console.log(this); };  foo(); // window  const obj = { foo }; obj.foo(); // obj  new foo(); // foo {} (instance)   일반 함수 호출      기본적으로 this에는 전역 객체가 바인딩 된다.   function foo() {   console.log(\"foo's this : \", this); // window   function bar() {     console.log(\"bar's this : \", this); // window   }   bar(); } foo();      전역 함수는 물론이고 중첩 함수를 일반 함수로 호출하면 함수 내부의 this에는 전역 객체가 바인딩된다.   this는 객체 내부의 프로퍼티와 메소드를 참조하기 위한 자기 참조 변수 이므로, 객체를 생성하지 않는 일반 함수에서 this는 의미가 없다. 따라서 strict mode 적용 시 이 경우에는 this에 undefined가 바인딩 된다.   var value = 1;  const obj = {   value: 100,   foo() {     console.log(\"foo's this : \", this); // { value : 100, foo: f}     console.log(\"foo's this.value: \", this.value); // 100;      function bar() {       console.log(\"bar's this : \", this); // window       console.log(\"bar's this.value: \", this.value); // 1     }     bar();     // 메서드 내에서 정의한 중첩 함수도 일반 함수로 호출되면 중첩 함수 내부의 this에는 전역 객체가 바인딩 된다.   }, };  obj.foo();      콜백 함수가 일반 함수로 호출되면 콜백 함수의 내부 this에도 전역 객체가 바인딩 된다.   어떠한 함수라도 일반 함수로 호출되면 this에 전역 객체가 바인딩 된다.   var value = 1;  const obj = {   value: 100,   foo() {     console.log(\"foo's this: \", this); // {value : 1, foo : f}     setTimeout(function () {       console.log(\"callback's this : \", this); // window       console.log(\"callback's this.value: \", this.value); // 1     }, 100);   }, };  obj.foo();      콜백 함수는 보통 외부 함수를 돕는 헬퍼 함수의 역할을 하는데, 위의 예시처럼 외부함수와 콜백함수의 this가 일치하지 않는다는 것은 중첩 함수 또는 콜백 함수를 헬퍼 함수로 동작하기 어렵게 만든다.   이 두 this 바인딩을 일치시키기 위해 다음의 방법을 사용할 수 있다.   // 일치용 변수 that 사용 const obj = {   value: 100,   foo() {     const that = this;     setTimeout(function () {       console.log(that.value); // 100     }, 100);   }, };  // bind 함수를 이용한 명시적 this 바인딩 var value = 1; const obj = {   value: 100,   foo() {     setTimeout(       function () {         console.log(this.balue); // 100       }.bind(this),       100     ); // 콜백 함수에 명시적으로 this를 바인딩 한다.   }, };  // 화살표 함수를 사용한 this 바인딩 var value = 1; const obj = {   value: 100,   foo() {     setTimeout(() =&gt; console.log(this.value), 100); // 100   }, }; obj.foo();   메서드 호출      메서드 내부의 this는 메서드를 소유한 객체가 아닌, 메서드 자신을 호출한 객체에 바인딩 된다. (???.method() -&gt; method에 바인딩)   const employee = {   depart: \"Dev\",   getDepart: function () {     return this.depart;   }, };  console.log(employee.getDepart()); // Dev      위 예제의 getDepart 프로퍼티는 함수 객체를 가리키고 있을 뿐이며, 이 가리키는 함수 객체는 employee 객체에 포함된 것이 아닌 독립적으로 존재하는 별도의 객체다.   const employee_2 = {     depart: \"UID\"; }  employee_2.getDepart = employee.getDepart;  console.log(employee.getDepart()); // UID  const getDepart = employee.getDepart;  console.log(getDepart()); // '' // 일반 함수로 호출된 getDepart 함수 내부의 this.name은 브라우저 환경에서 window.name과 같다.      위의 예시와 같이, getDepart 프로퍼티가 가리키는 함수 객체, 즉 getDepart 메서드는 다른 객체의 프로퍼티에 할당하는 것으로 다른 객체의 메서드가 될 수도 있고 일반 변수에 할당하여 일반 함수로 호출될 수도 있다.   function SoccerPlayer(position) {   this.position = position; }  SoccerPlayer.prototype.getPosition = function () {   return this.position; };  const son = new SoccerPlayer(\"Forward\"); console.log(son.getPosition()); // Forward  SoccerPlayer.prototype.position = \"Midfilder\";  console.log(SoccerPlayer.prototype.getPosition()); // Midfilder   생성자 함수 호출      생성자 함수 내부의 this에는 생섬자 함수가 (미래에) 생성할 인스턴스가 바인딩 된다.   function incomeTax(salary) {   this.salary = salary;   this.getIncomeTax = function () {     return salary * 0.1;   }; }  const tax1 = new incomeTax(20); const tax2 = new incomeTax(50);  console.log(tax1.getIncomeTax()); // 2 console.log(tax2.getIncomeTax()); // 5   Function.prototype.apply/call/bind 메서드에 의한 간접 호출           prototype.apply,call,bind Referance       apply, call 메서드의 기본 기능은 이 메서드가 붙은 함수를 호출하는 것이다.   일반 호출과 다른점은, 호출한 함수의 this에 apply, call에 담기는 인자(객체)를 바인딩 한다는 것이다.   function example() {   console.log(\"this : \", this);   console.log(\"arguments : \", arguments); }  const obj = {   name: \"example\", };  console.log(example.apply(obj, [\"arg1\", \"arg2\"])); // this : {name : 'example'} console.log(example.call(obj, \"arg1\", \"arg2\")); // arguments : ['arg1', 'arg2'];      Function.prototype.bind 메서드는 apply, call 메서드와 다르게 함수를 호출하지 않는다. 다만 인수로 전달한 값을 호출된 함수의 this에 바인딩 해 반환한다.   bind 메서드는 메서드의 this와 내부의 중첩 함수 또는 콜백 함수의 this가 불일치하는 문제를 해결하기 위해 사용된다.   const ex = {   name: \"innerName\",   getName(callback) {     setTimeout(callback, 100);   }, };  ex.getName(function () {   console.log(`'Hello! my name is ${this.name} !'`); // 'Hello! my name is !' });      객체.메소드() 의 경우 메소드의 this는 호출된 객체를 가리킨다. 때문에 ex.getName 메소드 실행 시 this.name에 innerName이 바인딩 되어야 할것 같지만   setTimeout의 콜백 함수가 일반 함수로서 호출된 시점에는 this에는 전역 객체 window가 바인딩 된다.   callback 함수는 getName을 돕는 헬퍼 함수 역할을 하지만, 내외부의 this가 불일치 하여 문맥상 문제가 발생한다. 이 this를 일치 시키기 위해 bind 메서드를 사용할 수 있다.   const ex = {   name: \"innerName\",   getName(callback) {     setTimeout(callback.bind(this), 100);   }, };  ex.getName(function () {   console.log(`'Hello! my name is ${this.name} !'`); // 'Hello! my name is innerName !'; });      bind 메서드는 인자로 받은 값을 호출된 함수의 this에 바인딩 시키고 그 함수를 리턴한다.   위의 예시와는 다르게 bind 메소드를 통해 강제로 getName 메서드 내부에서의 this를 바인딩 시켰기 때문에, 독립적으로 콜백 함수가 일반 함수로서 실행 되더라도 언제나 this에는 ex 객체가 바인딩 된다.  ","categories": ["book-study"],
        "tags": ["js-deepdive"],
        "url": "/book-study/Deepdive_about_this/",
        "teaser": null
      },{
        "title": "JavaScript Deepdive - Built-in Object",
        "excerpt":"자바스크립트 객체의 분류      자바스크립트 객체는 다음과 같이 크게 3개의 객체로 분류할 수 있다.       표준 빌트인 객체            ECMAScript 사양에 정의된 객체를 말하며, app 전역의 공통 기능을 제공한다.                    ECMAScript와 JavaScript는 무슨 차이점이 있을까?                       전역 객체의 프로퍼티로서 제공되기 때문에, 별도의 선언 없이 전역 변수처럼 언제나 참조 가능.           호스트 객체            ECMAScript 사양에 정의되어 있지않지만, JS 실행환경(브라우저 or Node.js)에서 추가로 제공하는 객체.       브라우저 제공 객체                    DOM, BOM, Canvas, XMLHttpRequest, fetch, requestAnimationFrame, SVG 등의 클라이언트 사이드 Web API를 호스트 객체로 제공하고, Node.js 환경에서는 Node.js 고유의 API를 호스트 객체로 제공한다.                                사용자 정의 객체              용어 그대로 사용자가 직접 정의한 객체.           표준 빌트인 객체      Object, String, Number, Boolean, Symbol, Date, Math, RegExp, Array, Map/Set, Function, Promise, Proxy, JSON 등 40여개의 표준 빌트인 객체를 제공한다.   Math, Reflect, JSON -&gt; 비 생성자 함수. 인스턴스 생성 불가능. 정적 메서드만 제공.   이외의 표준 빌트인 객체 -&gt; 생성자 함수. 인스턴스 생성 가능. 정적 메소드 및 프로토타입 메서드 제공.   const strObj = new String('Uber'); // String {\"Uber\"} console.log(typeof strObj); // object  const funObj = new Function('x', 'return x * x'); f annoymous(x) console.log(typeof funObj); // function      각 생성자 함수를 통해 생성된 인스턴스의 프로토타입은 각 생성자 객체의 prototype 프로퍼티에 바인딩된 객체다.   const strObj = new String(\"Lee\"); console.log(Object.getPrototypeOf(strObj) === String.prototype); // true   원시값과 래퍼 객체      문자열이나 숫자, 불리언 등의 원시값이 있는데도 String, Number, Boolean 등의 표준 빌트인 생성자 함수가 존재하는 이유는?       원시값은 객체가 아니므로 프로퍼티나 메서드를 가질 수 없는데도, 아래에서 원시값은 마치 객체처럼 동작한다.   const str = \"hello\";  console.log(str.length); // 5           이는 원시값인 문자열, 숫자, 불리언 값을 객체처럼 마침표 표기법으로 접근 시, 자바스크립트 엔진이 일시적으로 원시값과 연관된 객체를 생성하여 이 객체로 변환해서 해당 함수를 호출한뒤, 다시 원시값으로 되돌리기 때문이다.            이처럼 원시값에 객체처럼 접근하면 일시적으로 생성되는 임시 객체를 래퍼 객체(Wrapper object) 라고 한다.       // str.name이 undefined인 이유  const str = \"example\"; // 1 str.name = \"name\"; // 2  console.log(str.name); // undefined // 3      1에서 원시값 선언 및 초기화가 이루어진다.        2에서 마침표 표기법으로 name에 접근하면, ‘example’ 값과 연관된 객체(String)를 일시적으로 생성하여 str.name에 접근하게 해준다.            이 때 기존의 원시값은 래퍼객체의 [[StringData]] 내부 슬롯에 할당된다.            3에서 다시 str.name에 접근하면, 이 때 새롭게 생성되는 일시적 래퍼 객체는 2에서 생성된 래퍼객체와 다른 객체이다. (2에서 생성된 래퍼객체는 더이상 호출되지 않으므로 즉시 GC에 의해 수집됨.)       때문에 3에서 str.name은 undefined 상태가 된다.   String외에 Number, Boolean도 동일한 원리로 동작하며, 생성자 함수를 통해 인스턴스를 생성하지 않아도 객체처럼 사용할 수 있다. 때문에 String, Number, Boolean은 인스턴스 생성이 권장되지 않는다.   전역 객체      전역 객체는 코드가 실행되기 이전 단계에 JS 엔진에 의해 어떤 객체보다도 먼저 생성되는 특수한 객체이며, 어떤 객체에도 속하지 않은 최상위 객체다.            이 전역 객체는 환경에 따라 지칭하는 이름이 제각각이다. 브라우저 환경에서는 window, self, this, frames / Node.js 환경에서는 global이 전역 객체를 가리킨다.            ES11에서는 이를 통일하기 위해 globalThis를 표준 사양으로 지정했다.       globalThis === window; // true globalThis === this; // true globalThis === global; // true - Node.js globalThis === this; // true - Node.js           전역 객체는 표준 빌트인 객체(Object, String, Number 등)와 환경에 따른 호스트 객체(Client Web API or Node.js 호스트 API), 그리고 var 키워드로 선언한 전역 변수와 전역 함수를 프로퍼티로 갖는다.       전역 객체는 계층적 구조상 어떤 객체에도 속하지 않은 모든 빌트인 객체(표준 빌트인 객체와 호스트 객체)의 최상위 객체다.   하지만 이는 프로토타입 상속 관계 상 최상위 객체라는 의미는 아니다. 전역 객체 자신은 어떤 객체의 프로퍼티도 아니며, 객체의 계층적 구조상 표준 빌트인 객체와 호스트 객체를 프로퍼티로 소유한다는 것을 말한다.   var str = \"example\"; console.log(window.str); // example   전역 객체의 특징은 다음과 같다.      개발자가 의도적으로 생성할 수 없다. 즉, 전역 객체를 생성할 수 있는 생성자 함수가 제공되지 않는다.   전역 객체의 프로퍼티를 참조할 때, window(or global) 생략 가능.   // 문자열 F를 16진수로 해석하여 10진수로 변환하여 반환한다. window.parseInt(\"F\", 16); // 15  // 전역 객체의 프로퍼티는 window 생략 가능. parseInt(\"F\", 16); // 15  window.parseInt === parseInt; // true      전역 객체는 모든 표준 빌트인 객체를 프로퍼티로 가지고 있다.   자바 스크립트 실행 환경(브라우자 or Node.js)에 따라 추가적으로 프로퍼티와 메서드를 갖는다.   var 키워드로 선언한 전역 변수와 선언하지 않은 변수에 값을 할당한 암묵적 전역, 그리고 전역 함수는 객체의 프로퍼티가 된다.   var foo = 1; console.log(window.foo); // 1  bar = 2; console.log(window.bar); // 2  function baz() {   return 3; } console.log(baz()); // 3           let, const는 전역 객체 프로퍼티가 아니다. 이들은 보이지 않는 개념적인 블록(전역 렉시컬 환경의 선언적 환경 레코드) 내에 존재하게 된다.            브라우저 환경의 모든 JS 코드는 하나의 전역 객체 window를 공유한다. 여러개의 script 태그를 통해 JS 코드를 분리해도 마찬가지.       빌트인 전역 프로퍼티   Infinity      무한대를 나타내는 숫자값.   NaN      숫자가 아님을 나타내는 NaN을 갖는다. NaN === Number.NaN   undifined   빌트인 전역 함수      app 전역에서 호출할 수 있는 빌트인 함수로서 전역 객체의 메서드다.   eval      안티패턴. 사용 안하는걸 권장.   isFinite      인수의 유한수 / 무한수 여부 검증 및 boolean 반환.   isNaN   parseFloat, parseInt   encodeURI, decodeURI      encodeURI 함수는 완전한 URI를 문자열로 전달받아 이스케이프 처리를 위해 인코딩 하며, decodeURI는 이스케이프 처리 이전으로 디코딩 한다.   인코딩 : URI의 문자들을 이스케이프 처리하는 것.            이스케이프 : 네트워크를 통해 정보 공유 시 어떤 시스템에서도 해독 가능한 아스키 문자 셋으로 변환하는것.           URI 문법 형식 표준에 따르면 URL은 아스키 문자 셋으로만 구성 되어야 하며, 한글을 포함한 대부분의 외국어나 아스키 문자 셋에 정의되지 않은 특수문자의 경우 URL에 포함될 수 없다.   const uri = \"http://example.com?name=위버&amp;job=programmer&amp;teacher\";  console.log(encodeURI(uri)); // 'http://example.com?name=%EC%9C%84%EB%B2%84&amp;job=programmer&amp;teacher'   encodeURIComponent, decodeURIComponent      URI 구성요소를 인수로 전달받아 인코딩 한다. 이 때, 문자열을 URI의 구성요소인 쿼리 스트링의 일부로 간주하여 쿼리 스트링 구분자(&amp;, ?, =)는 인코딩 하지 않는다.   const uriComp = \"name=위버&amp;job=programmer&amp;teacher\";  console.log(encodeURIComponent(uriComp)); // \"name%3D%EC%9C%84%EB%B2%84%26job%3Dprogrammer%26teacher\"   암묵적 전역   var x = 10; // 전역 변수  function foo() {   y = 20; } foo();  console.log(x + y); // 30;      y는 선언하지 않은 식별자지만, JS 엔진은 y를 window.y로 해석하여 전역 객체에 프로퍼티를 동적으로 생성한다. 이 현상을 암묵적 전역이라 한다.   하지만 단지 프로퍼티로 추가되었을 뿐이며, 변수가 아니므로 호이스팅 대상 x  ","categories": ["book-study"],
        "tags": ["js-deepdive"],
        "url": "/book-study/Deepdive_builtinObject/",
        "teaser": null
      },{
        "title": "알고리즘 문제풀이 - 멘토링",
        "excerpt":"알고리즘 문제풀이 연습 - 6       제출한 답안  ","categories": ["coding-test"],
        "tags": ["Algorithm"],
        "url": "/coding-test/%EB%A9%98%ED%86%A0%EB%A7%81/",
        "teaser": null
      }]
