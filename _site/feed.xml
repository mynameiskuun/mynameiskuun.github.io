<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.9.4">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2024-02-19T00:35:44+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">오늘보다 나은 내일</title><subtitle>An amazing website.</subtitle><author><name>mynameiskuun</name></author><entry><title type="html">알고리즘 문제풀이 - 멘토링</title><link href="http://localhost:4000/coding-test/%EB%A9%98%ED%86%A0%EB%A7%81/" rel="alternate" type="text/html" title="알고리즘 문제풀이 - 멘토링" /><published>2024-02-15T00:00:00+09:00</published><updated>2024-02-15T00:00:00+09:00</updated><id>http://localhost:4000/coding-test/%EB%A9%98%ED%86%A0%EB%A7%81</id><content type="html" xml:base="http://localhost:4000/coding-test/%EB%A9%98%ED%86%A0%EB%A7%81/"><![CDATA[<h2 id="알고리즘-문제풀이-연습---6">알고리즘 문제풀이 연습 - 6</h2>

<p><img src="/assets/images/temp_leader.png" alt="Alt text" />
<img src="/assets/images/temp_leader2.png" alt="Alt text" /></p>

<h3 id="제출한-답안">제출한 답안</h3>]]></content><author><name>mynameiskuun</name></author><category term="coding-test" /><category term="Algorithm" /><summary type="html"><![CDATA[알고리즘 문제풀이 연습 - 6]]></summary></entry><entry><title type="html">JavaScript Deepdive - Built-in Object</title><link href="http://localhost:4000/book-study/Deepdive_builtinObject/" rel="alternate" type="text/html" title="JavaScript Deepdive - Built-in Object" /><published>2024-02-10T00:00:00+09:00</published><updated>2024-02-10T00:00:00+09:00</updated><id>http://localhost:4000/book-study/Deepdive_builtinObject</id><content type="html" xml:base="http://localhost:4000/book-study/Deepdive_builtinObject/"><![CDATA[<h2 id="자바스크립트-객체의-분류">자바스크립트 객체의 분류</h2>

<blockquote>
  <p>자바스크립트 객체는 다음과 같이 크게 3개의 객체로 분류할 수 있다.</p>
</blockquote>

<ul>
  <li>표준 빌트인 객체
    <ul>
      <li>ECMAScript 사양에 정의된 객체를 말하며, app 전역의 공통 기능을 제공한다.
        <ul>
          <li><a href="https://wormwlrm.github.io/2018/10/03/What-is-the-difference-between-javascript-and-ecmascript.html">ECMAScript와 JavaScript는 무슨 차이점이 있을까?</a></li>
        </ul>
      </li>
      <li>전역 객체의 프로퍼티로서 제공되기 때문에, 별도의 선언 없이 전역 변수처럼 언제나 참조 가능.</li>
    </ul>
  </li>
  <li>호스트 객체
    <ul>
      <li>ECMAScript 사양에 정의되어 있지않지만, JS 실행환경(브라우저 or Node.js)에서 추가로 제공하는 객체.</li>
      <li>브라우저 제공 객체
        <ul>
          <li>DOM, BOM, Canvas, XMLHttpRequest, fetch, requestAnimationFrame, SVG 등의 클라이언트 사이드 Web API를 호스트 객체로 제공하고, Node.js 환경에서는 Node.js 고유의 API를 호스트 객체로 제공한다.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <p>사용자 정의 객체</p>

    <ul>
      <li>용어 그대로 사용자가 직접 정의한 객체.</li>
    </ul>
  </li>
</ul>

<h2 id="표준-빌트인-객체">표준 빌트인 객체</h2>

<ul>
  <li>Object, String, Number, Boolean, Symbol, Date, Math, RegExp, Array, Map/Set, Function, Promise, Proxy, JSON 등 40여개의 표준 빌트인 객체를 제공한다.</li>
  <li>Math, Reflect, JSON -&gt; 비 생성자 함수. 인스턴스 생성 불가능. 정적 메서드만 제공.</li>
  <li>이외의 표준 빌트인 객체 -&gt; 생성자 함수. 인스턴스 생성 가능. 정적 메소드 및 프로토타입 메서드 제공.</li>
</ul>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">strObj</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">String</span><span class="p">(</span><span class="dl">'</span><span class="s1">Uber</span><span class="dl">'</span><span class="p">);</span> <span class="c1">// String {"Uber"}</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">typeof</span> <span class="nx">strObj</span><span class="p">);</span> <span class="c1">// object</span>

<span class="kd">const</span> <span class="nx">funObj</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Function</span><span class="p">(</span><span class="dl">'</span><span class="s1">x</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">return x * x</span><span class="dl">'</span><span class="p">);</span> <span class="nx">f</span> <span class="nx">annoymous</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">typeof</span> <span class="nx">funObj</span><span class="p">);</span> <span class="c1">// function</span>
</code></pre></div></div>

<ul>
  <li>각 생성자 함수를 통해 생성된 인스턴스의 프로토타입은 각 생성자 객체의 prototype 프로퍼티에 바인딩된 객체다.</li>
</ul>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">strObj</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">String</span><span class="p">(</span><span class="dl">"</span><span class="s2">Lee</span><span class="dl">"</span><span class="p">);</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nb">Object</span><span class="p">.</span><span class="nx">getPrototypeOf</span><span class="p">(</span><span class="nx">strObj</span><span class="p">)</span> <span class="o">===</span> <span class="nb">String</span><span class="p">.</span><span class="nx">prototype</span><span class="p">);</span> <span class="c1">// true</span>
</code></pre></div></div>

<h2 id="원시값과-래퍼-객체">원시값과 래퍼 객체</h2>

<blockquote>
  <p>문자열이나 숫자, 불리언 등의 원시값이 있는데도 String, Number, Boolean 등의 표준 빌트인 생성자 함수가 존재하는 이유는?</p>
</blockquote>

<ul>
  <li>원시값은 객체가 아니므로 프로퍼티나 메서드를 가질 수 없는데도, 아래에서 원시값은 마치 객체처럼 동작한다.</li>
</ul>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">str</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">hello</span><span class="dl">"</span><span class="p">;</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">str</span><span class="p">.</span><span class="nx">length</span><span class="p">);</span> <span class="c1">// 5</span>
</code></pre></div></div>

<ul>
  <li>
    <p>이는 원시값인 문자열, 숫자, 불리언 값을 객체처럼 마침표 표기법으로 접근 시, 자바스크립트 엔진이 일시적으로 원시값과 연관된 객체를 생성하여 이 객체로 변환해서 해당 함수를 호출한뒤, 다시 원시값으로 되돌리기 때문이다.</p>
  </li>
  <li>
    <p>이처럼 원시값에 객체처럼 접근하면 일시적으로 생성되는 임시 객체를 래퍼 객체(Wrapper object) 라고 한다.</p>
  </li>
</ul>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// str.name이 undefined인 이유</span>

<span class="kd">const</span> <span class="nx">str</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">example</span><span class="dl">"</span><span class="p">;</span> <span class="c1">// 1</span>
<span class="nx">str</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">name</span><span class="dl">"</span><span class="p">;</span> <span class="c1">// 2</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">str</span><span class="p">.</span><span class="nx">name</span><span class="p">);</span> <span class="c1">// undefined // 3</span>
</code></pre></div></div>

<ul>
  <li>1에서 원시값 선언 및 초기화가 이루어진다.</li>
  <li>
    <p>2에서 마침표 표기법으로 name에 접근하면, ‘example’ 값과 연관된 객체(String)를 일시적으로 생성하여 str.name에 접근하게 해준다.</p>
  </li>
  <li>
    <p>이 때 기존의 원시값은 래퍼객체의 [[StringData]] 내부 슬롯에 할당된다.</p>
  </li>
  <li>
    <p>3에서 다시 str.name에 접근하면, 이 때 새롭게 생성되는 일시적 래퍼 객체는 2에서 생성된 래퍼객체와 다른 객체이다. (2에서 생성된 래퍼객체는 더이상 호출되지 않으므로 즉시 GC에 의해 수집됨.)</p>
  </li>
  <li>때문에 3에서 str.name은 undefined 상태가 된다.</li>
</ul>

<h3 id="string외에-number-boolean도-동일한-원리로-동작하며-생성자-함수를-통해-인스턴스를-생성하지-않아도-객체처럼-사용할-수-있다-때문에-string-number-boolean은-인스턴스-생성이-권장되지-않는다">String외에 Number, Boolean도 동일한 원리로 동작하며, 생성자 함수를 통해 인스턴스를 생성하지 않아도 객체처럼 사용할 수 있다. 때문에 String, Number, Boolean은 인스턴스 생성이 권장되지 않는다.</h3>

<h2 id="전역-객체">전역 객체</h2>

<blockquote>
  <p>전역 객체는 코드가 실행되기 이전 단계에 JS 엔진에 의해 어떤 객체보다도 먼저 생성되는 특수한 객체이며, 어떤 객체에도 속하지 않은 최상위 객체다.</p>
</blockquote>

<ul>
  <li>
    <p>이 전역 객체는 환경에 따라 지칭하는 이름이 제각각이다. 브라우저 환경에서는 window, self, this, frames / Node.js 환경에서는 global이 전역 객체를 가리킨다.</p>
  </li>
  <li>
    <p>ES11에서는 이를 통일하기 위해 globalThis를 표준 사양으로 지정했다.</p>
  </li>
</ul>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">globalThis</span> <span class="o">===</span> <span class="nb">window</span><span class="p">;</span> <span class="c1">// true</span>
<span class="nx">globalThis</span> <span class="o">===</span> <span class="k">this</span><span class="p">;</span> <span class="c1">// true</span>
<span class="nx">globalThis</span> <span class="o">===</span> <span class="nb">global</span><span class="p">;</span> <span class="c1">// true - Node.js</span>
<span class="nx">globalThis</span> <span class="o">===</span> <span class="k">this</span><span class="p">;</span> <span class="c1">// true - Node.js</span>
</code></pre></div></div>

<ul>
  <li>
    <p>전역 객체는 표준 빌트인 객체(Object, String, Number 등)와 환경에 따른 호스트 객체(Client Web API or Node.js 호스트 API), 그리고 var 키워드로 선언한 전역 변수와 전역 함수를 프로퍼티로 갖는다.</p>
  </li>
  <li>전역 객체는 계층적 구조상 어떤 객체에도 속하지 않은 모든 빌트인 객체(표준 빌트인 객체와 호스트 객체)의 최상위 객체다.</li>
  <li>하지만 이는 프로토타입 상속 관계 상 최상위 객체라는 의미는 아니다. 전역 객체 자신은 어떤 객체의 프로퍼티도 아니며, 객체의 계층적 구조상 표준 빌트인 객체와 호스트 객체를 프로퍼티로 소유한다는 것을 말한다.</li>
</ul>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">str</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">example</span><span class="dl">"</span><span class="p">;</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nb">window</span><span class="p">.</span><span class="nx">str</span><span class="p">);</span> <span class="c1">// example</span>
</code></pre></div></div>

<h3 id="전역-객체의-특징은-다음과-같다">전역 객체의 특징은 다음과 같다.</h3>

<ul>
  <li>개발자가 의도적으로 생성할 수 없다. 즉, 전역 객체를 생성할 수 있는 생성자 함수가 제공되지 않는다.</li>
  <li>전역 객체의 프로퍼티를 참조할 때, window(or global) 생략 가능.</li>
</ul>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 문자열 F를 16진수로 해석하여 10진수로 변환하여 반환한다.</span>
<span class="nb">window</span><span class="p">.</span><span class="nb">parseInt</span><span class="p">(</span><span class="dl">"</span><span class="s2">F</span><span class="dl">"</span><span class="p">,</span> <span class="mi">16</span><span class="p">);</span> <span class="c1">// 15</span>

<span class="c1">// 전역 객체의 프로퍼티는 window 생략 가능.</span>
<span class="nb">parseInt</span><span class="p">(</span><span class="dl">"</span><span class="s2">F</span><span class="dl">"</span><span class="p">,</span> <span class="mi">16</span><span class="p">);</span> <span class="c1">// 15</span>

<span class="nb">window</span><span class="p">.</span><span class="nb">parseInt</span> <span class="o">===</span> <span class="nb">parseInt</span><span class="p">;</span> <span class="c1">// true</span>
</code></pre></div></div>

<ul>
  <li>전역 객체는 모든 표준 빌트인 객체를 프로퍼티로 가지고 있다.</li>
  <li>자바 스크립트 실행 환경(브라우자 or Node.js)에 따라 추가적으로 프로퍼티와 메서드를 갖는다.</li>
  <li>var 키워드로 선언한 전역 변수와 선언하지 않은 변수에 값을 할당한 암묵적 전역, 그리고 전역 함수는 객체의 프로퍼티가 된다.</li>
</ul>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">foo</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nb">window</span><span class="p">.</span><span class="nx">foo</span><span class="p">);</span> <span class="c1">// 1</span>

<span class="nx">bar</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nb">window</span><span class="p">.</span><span class="nx">bar</span><span class="p">);</span> <span class="c1">// 2</span>

<span class="kd">function</span> <span class="nx">baz</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="mi">3</span><span class="p">;</span>
<span class="p">}</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">baz</span><span class="p">());</span> <span class="c1">// 3</span>
</code></pre></div></div>

<ul>
  <li>
    <p>let, const는 전역 객체 프로퍼티가 아니다. 이들은 보이지 않는 개념적인 블록(전역 렉시컬 환경의 선언적 환경 레코드) 내에 존재하게 된다.</p>
  </li>
  <li>
    <p>브라우저 환경의 모든 JS 코드는 하나의 전역 객체 window를 공유한다. 여러개의 script 태그를 통해 JS 코드를 분리해도 마찬가지.</p>
  </li>
</ul>

<h2 id="빌트인-전역-프로퍼티">빌트인 전역 프로퍼티</h2>

<h3 id="infinity">Infinity</h3>

<ul>
  <li>무한대를 나타내는 숫자값.</li>
</ul>

<h3 id="nan">NaN</h3>

<ul>
  <li>숫자가 아님을 나타내는 NaN을 갖는다. NaN === Number.NaN</li>
</ul>

<h3 id="undifined">undifined</h3>

<h2 id="빌트인-전역-함수">빌트인 전역 함수</h2>

<ul>
  <li>app 전역에서 호출할 수 있는 빌트인 함수로서 전역 객체의 메서드다.</li>
</ul>

<h3 id="eval">eval</h3>

<ul>
  <li>안티패턴. 사용 안하는걸 권장.</li>
</ul>

<h3 id="isfinite">isFinite</h3>

<ul>
  <li>인수의 유한수 / 무한수 여부 검증 및 boolean 반환.</li>
</ul>

<h3 id="isnan">isNaN</h3>

<h3 id="parsefloat-parseint">parseFloat, parseInt</h3>

<h3 id="encodeuri-decodeuri">encodeURI, decodeURI</h3>

<ul>
  <li>encodeURI 함수는 완전한 URI를 문자열로 전달받아 이스케이프 처리를 위해 인코딩 하며, decodeURI는 이스케이프 처리 이전으로 디코딩 한다.</li>
  <li>인코딩 : URI의 문자들을 이스케이프 처리하는 것.
    <ul>
      <li>이스케이프 : 네트워크를 통해 정보 공유 시 어떤 시스템에서도 해독 가능한 아스키 문자 셋으로 변환하는것.</li>
    </ul>
  </li>
  <li>URI 문법 형식 표준에 따르면 URL은 아스키 문자 셋으로만 구성 되어야 하며, 한글을 포함한 대부분의 외국어나 아스키 문자 셋에 정의되지 않은 특수문자의 경우 URL에 포함될 수 없다.</li>
</ul>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">uri</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">http://example.com?name=위버&amp;job=programmer&amp;teacher</span><span class="dl">"</span><span class="p">;</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nb">encodeURI</span><span class="p">(</span><span class="nx">uri</span><span class="p">));</span>
<span class="c1">// 'http://example.com?name=%EC%9C%84%EB%B2%84&amp;job=programmer&amp;teacher'</span>
</code></pre></div></div>

<h3 id="encodeuricomponent-decodeuricomponent">encodeURIComponent, decodeURIComponent</h3>

<ul>
  <li>URI 구성요소를 인수로 전달받아 인코딩 한다. 이 때, 문자열을 URI의 구성요소인 쿼리 스트링의 일부로 간주하여 쿼리 스트링 구분자(&amp;, ?, =)는 인코딩 하지 않는다.</li>
</ul>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">uriComp</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">name=위버&amp;job=programmer&amp;teacher</span><span class="dl">"</span><span class="p">;</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nb">encodeURIComponent</span><span class="p">(</span><span class="nx">uriComp</span><span class="p">));</span>
<span class="c1">// "name%3D%EC%9C%84%EB%B2%84%26job%3Dprogrammer%26teacher"</span>
</code></pre></div></div>

<h2 id="암묵적-전역">암묵적 전역</h2>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">x</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span> <span class="c1">// 전역 변수</span>

<span class="kd">function</span> <span class="nx">foo</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">y</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span>
<span class="p">}</span>
<span class="nx">foo</span><span class="p">();</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">x</span> <span class="o">+</span> <span class="nx">y</span><span class="p">);</span> <span class="c1">// 30;</span>
</code></pre></div></div>

<ul>
  <li>y는 선언하지 않은 식별자지만, JS 엔진은 y를 window.y로 해석하여 전역 객체에 프로퍼티를 동적으로 생성한다. 이 현상을 암묵적 전역이라 한다.</li>
  <li>하지만 단지 프로퍼티로 추가되었을 뿐이며, 변수가 아니므로 호이스팅 대상 x</li>
</ul>]]></content><author><name>mynameiskuun</name></author><category term="book-study" /><category term="js-deepdive" /><summary type="html"><![CDATA[자바스크립트 객체의 분류]]></summary></entry><entry><title type="html">JavaScript Deepdive - this</title><link href="http://localhost:4000/book-study/Deepdive_about_this/" rel="alternate" type="text/html" title="JavaScript Deepdive - this" /><published>2024-02-10T00:00:00+09:00</published><updated>2024-02-10T00:00:00+09:00</updated><id>http://localhost:4000/book-study/Deepdive_about_this</id><content type="html" xml:base="http://localhost:4000/book-study/Deepdive_about_this/"><![CDATA[<h2 id="this-키워드">this 키워드</h2>

<ul>
  <li>자신이 속한 객체 또는 자신이 생성할 인스턴스를 가리키는 특수한 식별자를 this라고 하며, 이는 인스턴스 식별자를 알 수 없을 때 객체 내부의 프로퍼티와 메소드를 참조하기 위해서 만들어졌다.</li>
</ul>

<h3 id="객체-리터럴-방식">객체 리터럴 방식</h3>

<ul>
  <li>아래와 같은 객체 리터럴 방식의 객체에서는 getDiameter() 메서드가 속한 circle를 가리키는 식별자를 재귀적으로 참조할 수 있다.</li>
</ul>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">circle</span> <span class="o">=</span> <span class="p">{</span>
    <span class="nx">radius</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>

    <span class="nx">getDiameter</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="mi">2</span> <span class="o">*</span> <span class="nx">circle</span><span class="p">.</span><span class="nx">radius</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">circle</span><span class="p">.</span><span class="nx">getDiameter</span><span class="p">());</span> <span class="c1">// 10</span>
</code></pre></div></div>

<ul>
  <li>하지만 자기 자신이 속한 객체를 재귀적으로 참조하는 방식은 권장되지 않는다.</li>
</ul>

<h3 id="생성자-함수-방식">생성자 함수 방식</h3>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">Circle</span><span class="p">(</span><span class="nx">radius</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 이 시점에는 생성자 함수 자신이 생성할 인스턴스를 가리키는 식별자를 알 수 없다.</span>
    <span class="o">??</span><span class="p">?.</span><span class="nx">radius</span> <span class="o">=</span> <span class="nx">radius</span><span class="p">;</span>
<span class="p">}</span>

<span class="nx">Circle</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">getDIameter</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// 마찬가지로 식별자를 알 수 없다.</span>
    <span class="k">return</span> <span class="mi">2</span> <span class="o">*</span> <span class="o">????</span><span class="p">.</span><span class="nx">radius</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// 생성자 함수로 인스턴스를 생성하려면 먼저 생성자 함수를 정의해야 한다.</span>
<span class="kd">const</span> <span class="nx">circle</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Circle</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
</code></pre></div></div>

<ul>
  <li>생성자 함수를 통해 인스턴스를 생성하려면, 먼저 생성자 함수가 존재해야 한다.</li>
  <li>
    <p>하지만 이 생성자 함수에서 프로퍼티, 메서드 추가를 위해서는 자신이 생성할 인스턴스를 참조할 수 있어야 한다.</p>
  </li>
  <li>
    <p>이 모순을 해결하기 위해 this라는 특수한 식별자를 제공하여, 생성자 함수 내부에서 인스턴스를 생성하기 전에 인스턴스를 참조할 수 있다.</p>
  </li>
  <li>단, this가 가리키는 값, this 바인딩은 함수 호출 방식에 의해 동적으로 결정된다.</li>
</ul>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">this</span><span class="p">);</span> <span class="c1">// this : window</span>

<span class="kd">function</span> <span class="nx">ex</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">this</span><span class="p">);</span> <span class="c1">// this : window</span>
<span class="p">}</span>

<span class="kd">const</span> <span class="nx">person</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">name</span><span class="p">:</span> <span class="dl">"</span><span class="s2">Lee</span><span class="dl">"</span><span class="p">,</span>
  <span class="nx">getName</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">this</span><span class="p">);</span> <span class="c1">// this : {name: "lee", getName: f}</span>
    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">name</span><span class="p">;</span>
  <span class="p">},</span>
<span class="p">};</span>

<span class="kd">function</span> <span class="nx">Person</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span><span class="p">;</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">this</span><span class="p">);</span> <span class="c1">// this : Person {name: "lee"}</span>
<span class="p">}</span>

<span class="kd">const</span> <span class="nx">me</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Person</span><span class="p">(</span><span class="dl">"</span><span class="s2">lee</span><span class="dl">"</span><span class="p">);</span>
</code></pre></div></div>

<ul>
  <li>이 this는 객체의 프로퍼티나 메서드를 참조하기 위한 자기 참조 변수이므로, 일반적으로 객체의 메서드 내부 또는 생성자 함수 내부에서만 의미가 있다.</li>
</ul>

<h2 id="함수-호출-방식과-this-바인딩">함수 호출 방식과 this 바인딩</h2>

<ul>
  <li>this 바인딩은 함수 호출 방식, 즉 함수가 어떻게 호출되었는지에 따라 동적으로 결정된다.</li>
  <li>렉시컬 스코프와 this 바인딩은 결정 시기가 다르다.
    <ul>
      <li>렉시컬 스코프 : 함수의 상위 스코프를 결정하는 방식. 함수 정의가 평가되어 함수 객체가 생성되는 시점에 상위 스코프를 결정한다.</li>
      <li>this 바인딩 : 함수 호출 시점에 결정된다.</li>
    </ul>
  </li>
</ul>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">foo</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
<span class="p">};</span>

<span class="nx">foo</span><span class="p">();</span> <span class="c1">// window</span>

<span class="kd">const</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span> <span class="nx">foo</span> <span class="p">};</span>
<span class="nx">obj</span><span class="p">.</span><span class="nx">foo</span><span class="p">();</span> <span class="c1">// obj</span>

<span class="k">new</span> <span class="nx">foo</span><span class="p">();</span> <span class="c1">// foo {} (instance)</span>
</code></pre></div></div>

<h3 id="일반-함수-호출">일반 함수 호출</h3>

<ul>
  <li>기본적으로 this에는 전역 객체가 바인딩 된다.</li>
</ul>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">foo</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">foo's this : </span><span class="dl">"</span><span class="p">,</span> <span class="k">this</span><span class="p">);</span> <span class="c1">// window</span>
  <span class="kd">function</span> <span class="nx">bar</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">bar's this : </span><span class="dl">"</span><span class="p">,</span> <span class="k">this</span><span class="p">);</span> <span class="c1">// window</span>
  <span class="p">}</span>
  <span class="nx">bar</span><span class="p">();</span>
<span class="p">}</span>
<span class="nx">foo</span><span class="p">();</span>
</code></pre></div></div>

<ul>
  <li>전역 함수는 물론이고 중첩 함수를 일반 함수로 호출하면 함수 내부의 this에는 전역 객체가 바인딩된다.</li>
  <li>this는 객체 내부의 프로퍼티와 메소드를 참조하기 위한 자기 참조 변수 이므로, 객체를 생성하지 않는 일반 함수에서 this는 의미가 없다. 따라서 strict mode 적용 시 이 경우에는 this에 undefined가 바인딩 된다.</li>
</ul>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">value</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

<span class="kd">const</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">value</span><span class="p">:</span> <span class="mi">100</span><span class="p">,</span>
  <span class="nx">foo</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">foo's this : </span><span class="dl">"</span><span class="p">,</span> <span class="k">this</span><span class="p">);</span> <span class="c1">// { value : 100, foo: f}</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">foo's this.value: </span><span class="dl">"</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="nx">value</span><span class="p">);</span> <span class="c1">// 100;</span>

    <span class="kd">function</span> <span class="nx">bar</span><span class="p">()</span> <span class="p">{</span>
      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">bar's this : </span><span class="dl">"</span><span class="p">,</span> <span class="k">this</span><span class="p">);</span> <span class="c1">// window</span>
      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">bar's this.value: </span><span class="dl">"</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="nx">value</span><span class="p">);</span> <span class="c1">// 1</span>
    <span class="p">}</span>
    <span class="nx">bar</span><span class="p">();</span>
    <span class="c1">// 메서드 내에서 정의한 중첩 함수도 일반 함수로 호출되면 중첩 함수 내부의 this에는 전역 객체가 바인딩 된다.</span>
  <span class="p">},</span>
<span class="p">};</span>

<span class="nx">obj</span><span class="p">.</span><span class="nx">foo</span><span class="p">();</span>
</code></pre></div></div>

<ul>
  <li>콜백 함수가 일반 함수로 호출되면 콜백 함수의 내부 this에도 전역 객체가 바인딩 된다.</li>
  <li>어떠한 함수라도 일반 함수로 호출되면 this에 전역 객체가 바인딩 된다.</li>
</ul>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">value</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

<span class="kd">const</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">value</span><span class="p">:</span> <span class="mi">100</span><span class="p">,</span>
  <span class="nx">foo</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">foo's this: </span><span class="dl">"</span><span class="p">,</span> <span class="k">this</span><span class="p">);</span> <span class="c1">// {value : 1, foo : f}</span>
    <span class="nx">setTimeout</span><span class="p">(</span><span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">callback's this : </span><span class="dl">"</span><span class="p">,</span> <span class="k">this</span><span class="p">);</span> <span class="c1">// window</span>
      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">callback's this.value: </span><span class="dl">"</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="nx">value</span><span class="p">);</span> <span class="c1">// 1</span>
    <span class="p">},</span> <span class="mi">100</span><span class="p">);</span>
  <span class="p">},</span>
<span class="p">};</span>

<span class="nx">obj</span><span class="p">.</span><span class="nx">foo</span><span class="p">();</span>
</code></pre></div></div>

<ul>
  <li>콜백 함수는 보통 외부 함수를 돕는 헬퍼 함수의 역할을 하는데, 위의 예시처럼 외부함수와 콜백함수의 this가 일치하지 않는다는 것은 중첩 함수 또는 콜백 함수를 헬퍼 함수로 동작하기 어렵게 만든다.</li>
  <li>이 두 this 바인딩을 일치시키기 위해 다음의 방법을 사용할 수 있다.</li>
</ul>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 일치용 변수 that 사용</span>
<span class="kd">const</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">value</span><span class="p">:</span> <span class="mi">100</span><span class="p">,</span>
  <span class="nx">foo</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">that</span> <span class="o">=</span> <span class="k">this</span><span class="p">;</span>
    <span class="nx">setTimeout</span><span class="p">(</span><span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">that</span><span class="p">.</span><span class="nx">value</span><span class="p">);</span> <span class="c1">// 100</span>
    <span class="p">},</span> <span class="mi">100</span><span class="p">);</span>
  <span class="p">},</span>
<span class="p">};</span>

<span class="c1">// bind 함수를 이용한 명시적 this 바인딩</span>
<span class="kd">var</span> <span class="nx">value</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="kd">const</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">value</span><span class="p">:</span> <span class="mi">100</span><span class="p">,</span>
  <span class="nx">foo</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">setTimeout</span><span class="p">(</span>
      <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">balue</span><span class="p">);</span> <span class="c1">// 100</span>
      <span class="p">}.</span><span class="nx">bind</span><span class="p">(</span><span class="k">this</span><span class="p">),</span>
      <span class="mi">100</span>
    <span class="p">);</span> <span class="c1">// 콜백 함수에 명시적으로 this를 바인딩 한다.</span>
  <span class="p">},</span>
<span class="p">};</span>

<span class="c1">// 화살표 함수를 사용한 this 바인딩</span>
<span class="kd">var</span> <span class="nx">value</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="kd">const</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">value</span><span class="p">:</span> <span class="mi">100</span><span class="p">,</span>
  <span class="nx">foo</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">setTimeout</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">value</span><span class="p">),</span> <span class="mi">100</span><span class="p">);</span> <span class="c1">// 100</span>
  <span class="p">},</span>
<span class="p">};</span>
<span class="nx">obj</span><span class="p">.</span><span class="nx">foo</span><span class="p">();</span>
</code></pre></div></div>

<h3 id="메서드-호출">메서드 호출</h3>

<ul>
  <li>메서드 내부의 this는 메서드를 소유한 객체가 아닌, 메서드 자신을 호출한 객체에 바인딩 된다. (???.method() -&gt; method에 바인딩)</li>
</ul>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">employee</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">depart</span><span class="p">:</span> <span class="dl">"</span><span class="s2">Dev</span><span class="dl">"</span><span class="p">,</span>
  <span class="na">getDepart</span><span class="p">:</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">depart</span><span class="p">;</span>
  <span class="p">},</span>
<span class="p">};</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">employee</span><span class="p">.</span><span class="nx">getDepart</span><span class="p">());</span> <span class="c1">// Dev</span>
</code></pre></div></div>

<ul>
  <li>위 예제의 getDepart 프로퍼티는 함수 객체를 가리키고 있을 뿐이며, 이 가리키는 함수 객체는 employee 객체에 포함된 것이 아닌 독립적으로 존재하는 별도의 객체다.</li>
</ul>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">employee_2</span> <span class="o">=</span> <span class="p">{</span>
    <span class="na">depart</span><span class="p">:</span> <span class="dl">"</span><span class="s2">UID</span><span class="dl">"</span><span class="p">;</span>
<span class="p">}</span>

<span class="nx">employee_2</span><span class="p">.</span><span class="nx">getDepart</span> <span class="o">=</span> <span class="nx">employee</span><span class="p">.</span><span class="nx">getDepart</span><span class="p">;</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">employee</span><span class="p">.</span><span class="nx">getDepart</span><span class="p">());</span> <span class="c1">// UID</span>

<span class="kd">const</span> <span class="nx">getDepart</span> <span class="o">=</span> <span class="nx">employee</span><span class="p">.</span><span class="nx">getDepart</span><span class="p">;</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">getDepart</span><span class="p">());</span> <span class="c1">// ''</span>
<span class="c1">// 일반 함수로 호출된 getDepart 함수 내부의 this.name은 브라우저 환경에서 window.name과 같다.</span>
</code></pre></div></div>

<ul>
  <li>위의 예시와 같이, getDepart 프로퍼티가 가리키는 함수 객체, 즉 getDepart 메서드는 다른 객체의 프로퍼티에 할당하는 것으로 다른 객체의 메서드가 될 수도 있고 일반 변수에 할당하여 일반 함수로 호출될 수도 있다.</li>
</ul>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">SoccerPlayer</span><span class="p">(</span><span class="nx">position</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">position</span> <span class="o">=</span> <span class="nx">position</span><span class="p">;</span>
<span class="p">}</span>

<span class="nx">SoccerPlayer</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">getPosition</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">position</span><span class="p">;</span>
<span class="p">};</span>

<span class="kd">const</span> <span class="nx">son</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">SoccerPlayer</span><span class="p">(</span><span class="dl">"</span><span class="s2">Forward</span><span class="dl">"</span><span class="p">);</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">son</span><span class="p">.</span><span class="nx">getPosition</span><span class="p">());</span> <span class="c1">// Forward</span>

<span class="nx">SoccerPlayer</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">position</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">Midfilder</span><span class="dl">"</span><span class="p">;</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">SoccerPlayer</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">getPosition</span><span class="p">());</span> <span class="c1">// Midfilder</span>
</code></pre></div></div>

<h3 id="생성자-함수-호출">생성자 함수 호출</h3>

<ul>
  <li>생성자 함수 내부의 this에는 생섬자 함수가 (미래에) 생성할 인스턴스가 바인딩 된다.</li>
</ul>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">incomeTax</span><span class="p">(</span><span class="nx">salary</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">salary</span> <span class="o">=</span> <span class="nx">salary</span><span class="p">;</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">getIncomeTax</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">salary</span> <span class="o">*</span> <span class="mf">0.1</span><span class="p">;</span>
  <span class="p">};</span>
<span class="p">}</span>

<span class="kd">const</span> <span class="nx">tax1</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">incomeTax</span><span class="p">(</span><span class="mi">20</span><span class="p">);</span>
<span class="kd">const</span> <span class="nx">tax2</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">incomeTax</span><span class="p">(</span><span class="mi">50</span><span class="p">);</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">tax1</span><span class="p">.</span><span class="nx">getIncomeTax</span><span class="p">());</span> <span class="c1">// 2</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">tax2</span><span class="p">.</span><span class="nx">getIncomeTax</span><span class="p">());</span> <span class="c1">// 5</span>
</code></pre></div></div>

<h3 id="functionprototypeapplycallbind-메서드에-의한-간접-호출">Function.prototype.apply/call/bind 메서드에 의한 간접 호출</h3>

<ul>
  <li>
    <p><a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Function/apply">prototype.apply,call,bind Referance</a></p>
  </li>
  <li>apply, call 메서드의 기본 기능은 이 메서드가 붙은 함수를 호출하는 것이다.</li>
  <li>일반 호출과 다른점은, 호출한 함수의 this에 apply, call에 담기는 인자(객체)를 바인딩 한다는 것이다.</li>
</ul>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">example</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">this : </span><span class="dl">"</span><span class="p">,</span> <span class="k">this</span><span class="p">);</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">arguments : </span><span class="dl">"</span><span class="p">,</span> <span class="nx">arguments</span><span class="p">);</span>
<span class="p">}</span>

<span class="kd">const</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">name</span><span class="p">:</span> <span class="dl">"</span><span class="s2">example</span><span class="dl">"</span><span class="p">,</span>
<span class="p">};</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">example</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="nx">obj</span><span class="p">,</span> <span class="p">[</span><span class="dl">"</span><span class="s2">arg1</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">arg2</span><span class="dl">"</span><span class="p">]));</span> <span class="c1">// this : {name : 'example'}</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">example</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="nx">obj</span><span class="p">,</span> <span class="dl">"</span><span class="s2">arg1</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">arg2</span><span class="dl">"</span><span class="p">));</span> <span class="c1">// arguments : ['arg1', 'arg2'];</span>
</code></pre></div></div>

<ul>
  <li>Function.prototype.bind 메서드는 apply, call 메서드와 다르게 함수를 호출하지 않는다. 다만 인수로 전달한 값을 호출된 함수의 this에 바인딩 해 반환한다.</li>
  <li>bind 메서드는 메서드의 this와 내부의 중첩 함수 또는 콜백 함수의 this가 불일치하는 문제를 해결하기 위해 사용된다.</li>
</ul>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">ex</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">name</span><span class="p">:</span> <span class="dl">"</span><span class="s2">innerName</span><span class="dl">"</span><span class="p">,</span>
  <span class="nx">getName</span><span class="p">(</span><span class="nx">callback</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">setTimeout</span><span class="p">(</span><span class="nx">callback</span><span class="p">,</span> <span class="mi">100</span><span class="p">);</span>
  <span class="p">},</span>
<span class="p">};</span>

<span class="nx">ex</span><span class="p">.</span><span class="nx">getName</span><span class="p">(</span><span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">`'Hello! my name is </span><span class="p">${</span><span class="k">this</span><span class="p">.</span><span class="nx">name</span><span class="p">}</span><span class="s2"> !'`</span><span class="p">);</span> <span class="c1">// 'Hello! my name is !'</span>
<span class="p">});</span>
</code></pre></div></div>

<ul>
  <li>객체.메소드() 의 경우 메소드의 this는 호출된 객체를 가리킨다. 때문에 ex.getName 메소드 실행 시 this.name에 innerName이 바인딩 되어야 할것 같지만</li>
  <li>setTimeout의 콜백 함수가 일반 함수로서 호출된 시점에는 this에는 전역 객체 window가 바인딩 된다.</li>
  <li>callback 함수는 getName을 돕는 헬퍼 함수 역할을 하지만, 내외부의 this가 불일치 하여 문맥상 문제가 발생한다. 이 this를 일치 시키기 위해 bind 메서드를 사용할 수 있다.</li>
</ul>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">ex</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">name</span><span class="p">:</span> <span class="dl">"</span><span class="s2">innerName</span><span class="dl">"</span><span class="p">,</span>
  <span class="nx">getName</span><span class="p">(</span><span class="nx">callback</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">setTimeout</span><span class="p">(</span><span class="nx">callback</span><span class="p">.</span><span class="nx">bind</span><span class="p">(</span><span class="k">this</span><span class="p">),</span> <span class="mi">100</span><span class="p">);</span>
  <span class="p">},</span>
<span class="p">};</span>

<span class="nx">ex</span><span class="p">.</span><span class="nx">getName</span><span class="p">(</span><span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">`'Hello! my name is </span><span class="p">${</span><span class="k">this</span><span class="p">.</span><span class="nx">name</span><span class="p">}</span><span class="s2"> !'`</span><span class="p">);</span> <span class="c1">// 'Hello! my name is innerName !';</span>
<span class="p">});</span>
</code></pre></div></div>

<ul>
  <li>bind 메서드는 인자로 받은 값을 호출된 함수의 this에 바인딩 시키고 그 함수를 리턴한다.</li>
  <li>위의 예시와는 다르게 bind 메소드를 통해 강제로 getName 메서드 내부에서의 this를 바인딩 시켰기 때문에, 독립적으로 콜백 함수가 일반 함수로서 실행 되더라도 언제나 this에는 ex 객체가 바인딩 된다.</li>
</ul>]]></content><author><name>mynameiskuun</name></author><category term="book-study" /><category term="js-deepdive" /><summary type="html"><![CDATA[this 키워드]]></summary></entry><entry><title type="html">실용적인 자바스크립트 - Function</title><link href="http://localhost:4000/book-study/Practical_js_function/" rel="alternate" type="text/html" title="실용적인 자바스크립트 - Function" /><published>2024-02-02T00:00:00+09:00</published><updated>2024-02-02T00:00:00+09:00</updated><id>http://localhost:4000/book-study/Practical_js_function</id><content type="html" xml:base="http://localhost:4000/book-study/Practical_js_function/"><![CDATA[<h3 id="rest-parameter나머지-파라미터">Rest Parameter(나머지 파라미터)</h3>

<ul>
  <li>함수의 마지막 파라미터에 마침표 3개 (…)를 붙여 사실상 무한대의 파라미터를 사용할 수 있게 합니다.</li>
</ul>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">example</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">,</span> <span class="p">....</span><span class="nx">C</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
 <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span><span class="nx">b</span><span class="p">,</span><span class="nx">C</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>위의 경우, C 가변인자는 무한대의 파라미터를 받을 수 있기 때문에 배열로 출력 됩니다.</li>
</ul>

<hr />

<h3 id="arrow-function화살표-함수">Arrow Function(화살표 함수)</h3>

<ul>
  <li>자바의 람다 표현식과 유사한 것으로, 예시를 통해 쉽게 이해할 수 있습니다.</li>
</ul>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span><span class="nx">b</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">a</span> <span class="o">+</span> <span class="nx">b</span><span class="p">;</span>
<span class="p">}</span>

<span class="nx">화살표</span> <span class="nx">함수</span> <span class="nx">적용</span>

<span class="kd">var</span> <span class="nx">example</span> <span class="o">=</span> <span class="p">(</span><span class="nx">a</span><span class="p">,</span><span class="nx">b</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">a</span> <span class="o">+</span> <span class="nx">b</span><span class="p">;</span>
<span class="p">}</span>

</code></pre></div></div>

<h4 id="화살표-함수의-주요-특징">화살표 함수의 주요 특징</h4>

<ul>
  <li>함수 안에 super, this 바인딩이 없음.</li>
  <li>new 키워드 생성자를 사용할 수 있음.</li>
  <li>블록 스코프를 사용.</li>
</ul>

<blockquote>
  <p>화살표 함수 사용 시 유의사항</p>
</blockquote>

<ul>
  <li>=&gt; 화살표는 항상 변수 선언부와 동일한 row에 위치해야 합니다.</li>
</ul>

<hr />

<h3 id="일급-함수-고차-함수">일급 함수, 고차 함수</h3>

<blockquote>
  <p>일급 함수란, 다른 함수의 매개변수로 삽입되거나 return의 직접적인 대상이 될 수 있는 함수를 말합니다.</p>
</blockquote>

<hr />

<h3 id="변수의-스코프와-스코프-체인">변수의 스코프와 스코프 체인</h3>

<blockquote>
  <p>스코프(scope)란 ? 현재 실행 코드가 접근할 수 있는 선언되 변수의 범위를 말합니다. 반대로 말하면 변수가 영향을 미치는 코드의 범위입니다.</p>
</blockquote>

<ul>
  <li>자바스크립트의 3개의 스코프 타입은 각각 다른 스코프를 사용합니다.</li>
</ul>

<table>
  <thead>
    <tr>
      <th style="text-align: center">타입</th>
      <th style="text-align: center">스코프</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">var</td>
      <td style="text-align: center">함수 스코프</td>
    </tr>
    <tr>
      <td style="text-align: center">let</td>
      <td style="text-align: center">블록 스코프</td>
    </tr>
    <tr>
      <td style="text-align: center">const</td>
      <td style="text-align: center">블록 스코프</td>
    </tr>
  </tbody>
</table>

<ul>
  <li>함수 스코프 체인의 대표적인 예시</li>
</ul>

<p>```js var a = 1; var b = 5;
function outerFunc() {
  function innerFunc() {
    a = b;
  }
  console.log(a); //1
  a = 3;
  b = 4;
  innerFunc();
  console.log(a); //4
  var b = 2;
}
outerFunc();
console.log(a, b); //4,5</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
### 함수 선언과 함수 표현

- 함수 선언 예시

```js
function example(a, b) {
  console.log(a);
  console.log(b);
}
</code></pre></div></div>

<ul>
  <li>함수 표현 예시</li>
</ul>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">example</span> <span class="o">=</span> <span class="kd">function</span> <span class="nx">funcName</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="dl">"</span><span class="s2">example</span><span class="dl">"</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div>

<hr />

<h3 id="함수-표현과-함수-선언의-착각">함수 표현과 함수 선언의 착각</h3>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">a</span> <span class="o">=</span> <span class="kd">function</span> <span class="nx">nameFunc</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">nameFunc!</span><span class="dl">"</span><span class="p">);</span>
<span class="p">};</span>
</code></pre></div></div>

<blockquote>
  <p>위의 경우는 함수 표현입니다.</p>
</blockquote>

<ul>
  <li>함수 선언 몸체에 함수 이름이 있어도(nameFunc()) 변수에 대입을 하면(a) 함수 표현으로 선언됩니다.</li>
  <li>즉, nameFunc()은 함수가 아니기 때문에 사용할 수 없고, 함수 표현 변수명으로 호출해야(a()) 함수가 실행됩니다.</li>
</ul>

<hr />

<h3 id="함수-표현과-클로저">함수 표현과 클로저</h3>

<ul>
  <li>호이스팅이 지원되는 함수 선언을 사용하는것이 언뜻 보면 더 좋아보이지만, 이로 인해 여러개의 함수들이 호이스팅 되면 함수의 스코프 이슈를 피하기가 함들어집니다.</li>
  <li>이와 더불어 함수 표현을 사용하는 이유는 함수 표현이 클로저를 지원하기 때문입니다.</li>
</ul>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">buttons</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">querySelectorAll</span><span class="p">(</span><span class="dl">"</span><span class="s2">.button</span><span class="dl">"</span><span class="p">);</span>

<span class="kd">let</span> <span class="nx">i</span><span class="p">;</span>
<span class="k">for</span><span class="p">(</span><span class="nx">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="o">&gt;</span><span class="nx">buttons</span><span class="p">.</span><span class="nx">length</span><span class="p">;,</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">buttons</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nx">onclick</span> <span class="o">=</span> <span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">index</span><span class="dl">"</span> <span class="o">+</span> <span class="nx">i</span><span class="p">)};</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>위의 코드에서, i의 값에 따라 각각 1,2,3이 출력되야 할것 같지만, 루프문이 모두 실행된 후의 값인 i=3으로 모두 출력됩니다.</li>
  <li>버튼 클릭 시, 각각의 i를 출력시키려면 아래의 함수 표현(클로저 특성을 지닌)을 사용해야 합니다.</li>
</ul>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">buttons</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">querySelectorAll</span><span class="p">(</span><span class="dl">'</span><span class="s1">.button</span><span class="dl">'</span><span class="p">);</span>

<span class="kd">let</span> <span class="nx">clickHandler</span> <span class="o">=</span> <span class="p">(</span><span class="nx">index</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="k">return</span> <span class="o">=&gt;</span> <span class="p">{</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">index : </span><span class="dl">"</span> <span class="o">+</span> <span class="nx">index</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">let</span> <span class="nx">i</span><span class="p">;</span>
<span class="k">for</span><span class="p">(</span><span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">buttons</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">button</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nx">onclick</span> <span class="o">=</span> <span class="nx">clickHandler</span><span class="p">(</span><span class="nx">i</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="인터페이스-함수">인터페이스 함수</h3>

<ul>
  <li>자바스크립트의 객체 작성 기법중 하나.</li>
  <li>한 개 이상의 함수를 함수로 다시 감싸서 객체, 정확히는 객체 리터럴을 반환하는 래퍼(Wrapper) 함수의 역할을 하는 함수를 말합니다.</li>
  <li>return으로 함수 안에 정의한 함수들의 이름을 담은 객체 리터럴을 반환한다.</li>
</ul>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">math</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">function</span> <span class="nx">plus</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">a</span> <span class="o">+</span> <span class="nx">b</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">minus</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">a</span> <span class="o">-</span> <span class="nx">b</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">multiple</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">a</span> <span class="o">*</span> <span class="nx">b</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">divide</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">a</span> <span class="o">/</span> <span class="nx">b</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="p">{</span> <span class="nx">plus</span><span class="p">,</span> <span class="nx">minus</span><span class="p">,</span> <span class="nx">multiple</span><span class="p">,</span> <span class="nx">divide</span> <span class="p">};</span>
<span class="p">}</span>

<span class="kd">const</span> <span class="nx">math</span> <span class="o">=</span> <span class="nx">math</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">50</span><span class="p">);</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">math</span><span class="p">.</span><span class="nx">plus</span><span class="p">());</span> <span class="c1">// 150</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">math</span><span class="p">.</span><span class="nx">minus</span><span class="p">());</span> <span class="c1">// 50</span>
</code></pre></div></div>

<h3 id="커링currying-함수">커링(Currying) 함수</h3>

<ul>
  <li>단일 호출로 처리하는 여러 파라미터를 가진 함수를 단일 파라미터를 사용하는 중첩 함수로 분리해서 사용하는 기법.</li>
</ul>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">add</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">a</span> <span class="o">+</span> <span class="nx">b</span><span class="p">;</span>
<span class="p">}</span>
<span class="nx">add</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
</code></pre></div></div>

<blockquote>
  <p>Currying ver</p>
</blockquote>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">add</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">b</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">a</span> <span class="o">+</span> <span class="nx">b</span><span class="p">;</span>
  <span class="p">};</span>
<span class="p">}</span>

<span class="nx">add</span><span class="p">(</span><span class="mi">1</span><span class="p">)(</span><span class="mi">2</span><span class="p">);</span>
</code></pre></div></div>

<ul>
  <li>
    <p>부분 실행하는 단계를 분리 해 코드를 나눌 수 있지만, 파라미터 개수가 많고 중첩이 깊어지면 콜 스택 유지에 메모리를 더 사용하여 실행 속도 측면에서 불리해짐. 또한 중첩이 깊어지면 가독성 하락.</p>
  </li>
  <li>
    <p>화살표 함수를 이용해 짧은 코드로도 작성 가능.</p>
  </li>
</ul>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">sum</span> <span class="o">=</span> <span class="p">(</span><span class="nx">num1</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">(</span><span class="nx">num2</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">(</span><span class="nx">num3</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">num1</span> <span class="o">+</span> <span class="nx">num2</span> <span class="o">+</span> <span class="nx">num3</span><span class="p">;</span>
</code></pre></div></div>

<h3 id="재귀-커링">재귀 커링</h3>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">sum</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">b</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">b</span> <span class="o">===</span> <span class="kc">undefined</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">a</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">sum</span><span class="p">(</span><span class="nx">a</span> <span class="o">+</span> <span class="nx">b</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">};</span>
<span class="p">}</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">sum</span><span class="p">(</span><span class="mi">1</span><span class="p">)());</span> <span class="c1">// 1</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">sum</span><span class="p">(</span><span class="mi">1</span><span class="p">)(</span><span class="mi">2</span><span class="p">)());</span> <span class="c1">// 3</span>
</code></pre></div></div>

<ul>
  <li>마지막 고차함수를 즉시실행 시키기 위해 빈 괄호를 넣으며, 재귀 커링 함수는 반드시 이렇게 구현해야 함.</li>
</ul>

<h3 id="믹스인-함수">믹스인 함수</h3>

<ul>
  <li>단일 객체 상속의 한계를 넘어, 여러 객체에서 메소드나 속성을 상속받을 수 있게 하는 함수.</li>
  <li>객체의 메소드, 속성을 모두 대상 객체로 복사 하며, 이름이 중복되면 값을 덮어씀.</li>
  <li>jQuery의 $.extend 메소드와 유사한 기능.</li>
</ul>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">mixin</span><span class="p">(</span><span class="nx">sourceObj</span><span class="p">,</span> <span class="nx">targetObj</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">assign</span><span class="p">(</span><span class="nx">sourceObj</span><span class="p">,</span> <span class="nx">targetObj</span><span class="p">);</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="p">{</span> <span class="na">name</span><span class="p">:</span> <span class="dl">"</span><span class="s2">sam</span><span class="dl">"</span><span class="p">,</span> <span class="na">age</span><span class="p">:</span> <span class="mi">20</span> <span class="p">};</span>
<span class="kd">var</span> <span class="nx">b</span> <span class="o">=</span> <span class="p">{</span> <span class="na">age</span><span class="p">:</span> <span class="mi">21</span><span class="p">,</span> <span class="na">addr</span><span class="p">:</span> <span class="dl">"</span><span class="s2">seoul</span><span class="dl">"</span> <span class="p">};</span>

<span class="kd">var</span> <span class="nx">c</span> <span class="o">=</span> <span class="nx">mixin</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">);</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">c</span><span class="p">);</span> <span class="c1">// {name : "sam", age : 21, addr : "seoul"};</span>
</code></pre></div></div>

<h3 id="디바운스-함수">디바운스 함수</h3>

<ul>
  <li>디바운싱 이란, 동일 함수의 잦은 반복 실행을 차단하고 마지막 호출한 것만 실행되도록 하는 코딩 패턴.
    <ul>
      <li>검색어 입력 시, 매 키보드 입력 마다 api 호출이 된다면?</li>
    </ul>
  </li>
</ul>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="kd">function</span> <span class="nx">debounceFunc</span><span class="p">(</span><span class="nx">callback</span><span class="p">,</span> <span class="nx">delay</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">timer</span><span class="p">;</span>

  <span class="k">return</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span> <span class="c1">// 디바운스 함수</span>
    <span class="k">if</span><span class="p">(</span><span class="nx">timer</span><span class="p">)</span> <span class="nx">clearTimeout</span><span class="p">(</span><span class="nx">timer</span><span class="p">);</span>
    <span class="nx">timer</span> <span class="o">=</span> <span class="nx">setTimeout</span><span class="p">{</span><span class="nx">callback</span><span class="p">,</span> <span class="nx">delay</span><span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">runner</span><span class="p">()</span> <span class="p">{</span> <span class="c1">// 콜백 함수</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">new</span> <span class="nb">Date</span><span class="p">());</span>
<span class="p">}</span>

<span class="kd">let</span> <span class="nx">df</span> <span class="o">=</span> <span class="nx">debounceFunc</span><span class="p">(</span><span class="nx">runner</span><span class="p">,</span> <span class="mi">1000</span><span class="p">);</span>
</code></pre></div></div>]]></content><author><name>mynameiskuun</name></author><category term="book-study" /><category term="practical-js" /><summary type="html"><![CDATA[Rest Parameter(나머지 파라미터)]]></summary></entry><entry><title type="html">실용적인 자바스크립트 - Basic</title><link href="http://localhost:4000/book-study/Practical_js_basic/" rel="alternate" type="text/html" title="실용적인 자바스크립트 - Basic" /><published>2024-02-02T00:00:00+09:00</published><updated>2024-02-02T00:00:00+09:00</updated><id>http://localhost:4000/book-study/Practical_js_basic</id><content type="html" xml:base="http://localhost:4000/book-study/Practical_js_basic/"><![CDATA[<h3 id="폴리필polyfill">폴리필(Polyfill)</h3>

<ul>
  <li>해당 기능을 지원할 수 없거나, 호환성 문제로 인해 같은 기능이 다르게 실행될 때, 기능을 사용할 수 있도록 대체 구현을 하는 코드, 또는 라이브러리를 말한다.</li>
</ul>

<h3 id="promise">Promise</h3>

<ul>
  <li>자바스크립트의 비동기 객체 (Promise)를 한글로 사용하면서 혼용 하고 있음.</li>
</ul>

<h3 id="fetch">Fetch</h3>

<ul>
  <li>자바스크립트의 비동기 통신 기능. 상기 Promise를 보다 쉽게 사용할 수 있도록 제공되는 프로미스의 Wrapper 기능.</li>
</ul>

<h3 id="동기sync-와-비동기async">동기(Sync) 와 비동기(Async)</h3>

<ul>
  <li>동기는 코드가 순차적으로 실행되는것. 비동기는 앞쪽에 나오는 코드가 나중에 실행될 수 있는것. JS는 Promise와 같은 비동기 내장 객체를 지원한다.</li>
</ul>

<h3 id="스코프scope">스코프(Scope)</h3>

<ul>
  <li>변수, 또는 코드가 영향을 미치는범위.</li>
</ul>

<h3 id="전역global-함수function-블록block-로컬-스코프local-scope">전역(Global), 함수(Function), 블록(Block), 로컬 스코프(Local Scope)</h3>

<ul>
  <li>var는 전역과 함수 스코프를 지원하며, let, const는 전역과 블록 스코프를 지원한다.</li>
  <li>함수 스코프는 함수 안에서만 접근이 가능한 지역변수가 되며, 블록 스코프는 블록 안에서만 접근이 가능하다.</li>
  <li>let, const는 보다 정밀한 스코프 제어가 가능하고, 덕분에 리소스 낭비가 적다.</li>
  <li>로컬 스코프는 전역이 아닌 함수, 블록 스코프를 말한다.</li>
</ul>

<h3 id="순회traversal와-순환rotation">순회(Traversal)와 순환(Rotation)</h3>

<ul>
  <li>JS의 순회란 방문해야 할 지점을 한번씩 방문하고 종료하는것. (ex. DOM 탐색 등)</li>
  <li>순환이란 순회를 계속 반복하는것.</li>
</ul>

<h3 id="호이스팅hoisting">호이스팅(Hoisting)</h3>

<ul>
  <li>변수와 함수 선언을 포함한 모든 선언을 스코프 최상단으로 끌어올려 스코프 안의 모든 코드에서 선언 정보에 접근이 가능하도록 하는 JS의 주요 기능.</li>
  <li>var, let, const, function, class와 같은 선언이 호이스팅 대상.</li>
</ul>

<blockquote>
  <p>호이스팅 예시와 호이스팅 과정</p>
</blockquote>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">a</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">a</span><span class="p">);</span>

<span class="c1">// 1. var a = undefined;</span>
<span class="c1">// 2. a = 0;</span>
<span class="c1">// 3. a = 10;</span>
</code></pre></div></div>

<h3 id="생성자-함수constructor-function">생성자 함수(Constructor Function)</h3>

<ul>
  <li>반드시 “new” 연산자를 사용해 호출하며, 함수 이름 첫글자는 대문자로 시작.</li>
  <li>생성자 함수와 일반 함수 사이에 기술적인 차이는 없다.</li>
  <li>“new” 연산자를 써서 함수를 실행하면 아래와 같은 알고리즘이 동작한다.
    <ul>
      <li>빈 객체를 만들어 this에 할당합니다.</li>
      <li>함수 본문을 실행합니다. this에 새로운 프로퍼티를 추가해 this를 수정합니다.</li>
      <li>this를 반환한다.</li>
    </ul>
  </li>
</ul>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">Cellphone</span><span class="p">(</span><span class="nx">brand</span><span class="p">,</span> <span class="nx">price</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">brand</span> <span class="o">=</span> <span class="nx">brand</span><span class="p">;</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">price</span> <span class="o">=</span> <span class="nx">price</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">iPhone</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Cellphone</span><span class="p">(</span><span class="dl">"</span><span class="s2">apple</span><span class="dl">"</span><span class="p">,</span> <span class="mi">12000000</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">galaxy</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Cellphone</span><span class="p">(</span><span class="dl">"</span><span class="s2">samsung</span><span class="dl">"</span><span class="p">,</span> <span class="mi">12000000</span><span class="p">);</span>

<span class="c1">//</span>

<span class="kd">var</span> <span class="nx">iphone</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">brand</span><span class="p">:</span> <span class="dl">"</span><span class="s2">apple</span><span class="dl">"</span><span class="p">,</span>
  <span class="na">price</span><span class="p">:</span> <span class="mi">12000000</span><span class="p">,</span>
<span class="p">};</span>

<span class="kd">var</span> <span class="nx">galaxy</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">brand</span><span class="p">:</span> <span class="dl">"</span><span class="s2">samsung</span><span class="dl">"</span><span class="p">,</span>
  <span class="na">price</span><span class="p">:</span> <span class="mi">12000000</span><span class="p">,</span>
<span class="p">};</span>
</code></pre></div></div>

<h3 id="제너레이터-함수generator-function">제너레이터 함수(Generator function)</h3>

<ul>
  <li>생성자 함수와 혼동하기 쉽지만, 전혀 다름.</li>
  <li>함수를 여러번 반복하며 순차적으로 반복적인 값을 얻을 수 있는 특별한 함수.</li>
  <li>function* 혹은 함수이름앞에 *를 붙임. 보통 전자의 경우를 많이 사용함.</li>
</ul>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span><span class="o">*</span> <span class="nx">generator</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">yield</span> <span class="mi">1</span><span class="p">;</span>
  <span class="k">yield</span> <span class="mi">2</span><span class="p">;</span>
  <span class="k">yield</span> <span class="mi">3</span><span class="p">;</span>
  <span class="k">return</span> <span class="mi">4</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">let</span> <span class="nx">init</span> <span class="o">=</span> <span class="nx">generator</span><span class="p">();</span>
<span class="kd">let</span> <span class="nx">one</span> <span class="o">=</span> <span class="nx">init</span><span class="p">.</span><span class="nx">next</span><span class="p">();</span>
<span class="kd">let</span> <span class="nx">two</span> <span class="o">=</span> <span class="nx">init</span><span class="p">.</span><span class="nx">next</span><span class="p">();</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">one</span><span class="p">);</span> <span class="c1">// 1</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">tow</span><span class="p">);</span> <span class="c1">// 2</span>
</code></pre></div></div>

<h3 id="클로저-함수closure-function">클로저 함수(Closure function)</h3>

<ul>
  <li>실행 시점, 또는 호출 시점의 렉시컬 환경(Lexical Environment)을 호출된 함수에서 기억하는 것을 클로저라고 한다.</li>
  <li>렉시컬 환경이란, 현재 실행 context의 스코프에 있는 선언 정보와 값을 말한다.</li>
</ul>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;button</span> <span class="na">id=</span><span class="s">"btn1"</span><span class="nt">&gt;</span>버튼1<span class="nt">&lt;/button&gt;</span>
<span class="nt">&lt;button</span> <span class="na">id=</span><span class="s">"btn2"</span><span class="nt">&gt;</span>버튼2<span class="nt">&lt;/button&gt;</span>
<span class="nt">&lt;button</span> <span class="na">id=</span><span class="s">"btn3"</span><span class="nt">&gt;</span>버튼3<span class="nt">&lt;/button&gt;</span>

<span class="nt">&lt;script&gt;</span>
  <span class="kd">function</span> <span class="nx">count</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">return</span> <span class="p">{</span>
      <span class="na">plusCnt</span><span class="p">:</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
        <span class="nx">cnt</span><span class="o">++</span><span class="p">;</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">cnt</span><span class="p">);</span>
      <span class="p">},</span>
    <span class="p">};</span>
  <span class="p">}</span>

  <span class="kd">var</span> <span class="nx">countIIFE</span> <span class="o">=</span> <span class="p">(</span><span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">return</span> <span class="p">{</span>
      <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
        <span class="nx">cnt</span><span class="o">++</span><span class="p">;</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">cnt</span><span class="p">);</span>
      <span class="p">},</span>
    <span class="p">};</span>
  <span class="p">})();</span>

  <span class="kd">let</span> <span class="nx">count1</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">count</span><span class="p">();</span>
  <span class="kd">let</span> <span class="nx">count2</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">count</span><span class="p">();</span>
  <span class="kd">let</span> <span class="nx">count3</span> <span class="o">=</span> <span class="nx">countIIFE</span><span class="p">;</span>

  <span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="dl">"</span><span class="s2">btn1</span><span class="dl">"</span><span class="p">).</span><span class="nx">addEventListener</span><span class="p">(</span><span class="dl">"</span><span class="s2">click</span><span class="dl">"</span><span class="p">,</span> <span class="nx">count1</span><span class="p">.</span><span class="nx">plusCnt</span><span class="p">);</span>
  <span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="dl">"</span><span class="s2">btn2</span><span class="dl">"</span><span class="p">).</span><span class="nx">addEventListener</span><span class="p">(</span><span class="dl">"</span><span class="s2">click</span><span class="dl">"</span><span class="p">,</span> <span class="nx">count2</span><span class="p">.</span><span class="nx">plusCnt</span><span class="p">);</span>
  <span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="dl">"</span><span class="s2">btn3</span><span class="dl">"</span><span class="p">).</span><span class="nx">addEventListener</span><span class="p">(</span><span class="dl">"</span><span class="s2">click</span><span class="dl">"</span><span class="p">,</span> <span class="nx">count3</span><span class="p">);</span>
<span class="nt">&lt;/script&gt;</span>
</code></pre></div></div>

<h3 id="클로저-기초">클로저 기초</h3>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">outerFunc</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">saying</span> <span class="o">=</span> <span class="nx">name</span> <span class="o">+</span> <span class="dl">"</span><span class="s2">안녕!</span><span class="dl">"</span><span class="p">;</span>
  <span class="k">return</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">saying</span><span class="p">;</span>
  <span class="p">};</span>
<span class="p">}</span>

<span class="kd">let</span> <span class="nx">closure1</span> <span class="o">=</span> <span class="nx">outerFunc</span><span class="p">(</span><span class="dl">"</span><span class="s2">라이언</span><span class="dl">"</span><span class="p">);</span>
<span class="kd">let</span> <span class="nx">closure2</span> <span class="o">=</span> <span class="nx">outerFunc</span><span class="p">(</span><span class="dl">"</span><span class="s2">콘</span><span class="dl">"</span><span class="p">);</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">closure1</span><span class="p">);</span> <span class="c1">// 라이언 안녕!</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">closure2</span><span class="p">);</span> <span class="c1">// 콘 안녕!</span>
</code></pre></div></div>

<ul>
  <li>outerFunc() 함수는 익명 함수를 반환하고 종료되며, 로컬변수 saying도 사라져야 한다.</li>
  <li>하지만 closure1, closure2를 실행하면 이미 종료된 부모함수 outerFunc의 saying 변수에 접근 가능.</li>
  <li>자식 함수에 해당하는 익명 함수가 부모 함수인 outerFunc() 함수의 실행 환경에 속한 saying 변수에 부모 함수 종료 후 접근할 수 있는것을 클로저 라고 하며, 익명 함수는 클로저 함수가 된다.</li>
</ul>

<h3 id="var-let-const의-차이">var, let, const의 차이</h3>

<table>
  <thead>
    <tr>
      <th>선언자</th>
      <th>중복선언</th>
      <th>재할당</th>
      <th>초기값</th>
      <th>스코프</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>var</td>
      <td>가능</td>
      <td>가능</td>
      <td>undefined</td>
      <td>함수</td>
    </tr>
    <tr>
      <td>let</td>
      <td>불가능</td>
      <td>가능</td>
      <td>undefined</td>
      <td>블록</td>
    </tr>
    <tr>
      <td>const</td>
      <td>불가능</td>
      <td>불가능</td>
      <td>불가능</td>
      <td>블록</td>
    </tr>
  </tbody>
</table>

<h3 id="절대값-숫자의-부호를-얻기">절대값, 숫자의 부호를 얻기</h3>

<ul>
  <li>Math.abs() -&gt; 부호 없는 양의 숫자 값을 반환. (절대값)</li>
  <li>Math.sign() -&gt; 숫자의 부호를 알려줌. 1, 0, -1, NaN 중 1개 반환</li>
</ul>

<h3 id="truefalse의-판단">true/false의 판단</h3>

<ul>
  <li>false, null, undefined, ‘’, 0, NaN 모두 false로 판단.</li>
</ul>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="p">(</span><span class="nx">data</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">data</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="null-undefined-0의-차이">null, undefined, 0의 차이</h3>

<ul>
  <li>JS에서 값이 할당되지 않은것을 표현하는 방법은 2가지.
    <ul>
      <li>Null. 변수가 빈 값으로 초기화 된 상태.
        <ul>
          <li>사용자가 명시적으로 변수에 대입 하는 경우 외에는 발생하지 않음.</li>
        </ul>
      </li>
      <li>undefined. 사용자에 의해 변수에 값이 대입되지 않은 초기 상태의 변수.
        <ul>
          <li>선언은 되었지만 초기화는 되지 않은 상태.</li>
          <li>ex) let a;</li>
          <li>
            <h2 id="이와-관련해서-함수-정의-시-불필요하게-많은-파라미터를-정의하는-것은-굉장히-좋지-않은-결과를-낳을-수-있음">이와 관련해서, 함수 정의 시 불필요하게 많은 파라미터를 정의하는 것은 굉장히 좋지 않은 결과를 낳을 수 있음.</h2>
          </li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h3 id="인자argument와-파라미터parameter의-차이">인자(Argument)와 파라미터(Parameter)의 차이</h3>

<ul>
  <li>파라미터는 함수 정의 시 나열하는 변수명. 인자는 함수를 호출할 때 전달하는 실제 값.</li>
</ul>

<h3 id="객체object">객체(Object)</h3>

<ul>
  <li>JS의 객체는 다양한 종류의 데이터들을 하나의 저장소에 담아 접근 및 관리하기 위해 사용.</li>
</ul>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">example</span> <span class="o">=</span> <span class="p">{</span> <span class="na">company</span><span class="p">:</span> <span class="dl">"</span><span class="s2">uber</span><span class="dl">"</span><span class="p">,</span> <span class="na">depart</span><span class="p">:</span> <span class="dl">"</span><span class="s2">dev</span><span class="dl">"</span><span class="p">,</span> <span class="na">floor</span><span class="p">:</span> <span class="mi">2</span> <span class="p">};</span>
</code></pre></div></div>

<ul>
  <li>함수 자체를 객체에 저장할 수도 있음.</li>
</ul>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">example</span> <span class="o">=</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">say</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">Hello!</span><span class="dl">'</span><span class="p">;</span>
    <span class="nl">sayHello</span> <span class="p">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">say</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>컨벤션
    <ul>
      <li>key, value 사이에 공백을 하나 둔다.</li>
      <li>객체 요소 구분자 쉼표 뒤에는 공백을 하나 둔다.</li>
      <li>문자열 값 표현은 쌍따옴표를 사용하는것을 권장한다.</li>
    </ul>
  </li>
  <li>하나의 객체 안에는 하나의 키만 존재. but 하위 객체에 중복 key 선언 가능.</li>
</ul>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">example</span> <span class="o">=</span> <span class="p">{</span> <span class="na">company</span><span class="p">:</span> <span class="dl">"</span><span class="s2">uber</span><span class="dl">"</span><span class="p">,</span> <span class="na">depart</span><span class="p">:</span> <span class="dl">"</span><span class="s2">dev</span><span class="dl">"</span><span class="p">,</span> <span class="na">depart</span><span class="p">:</span> <span class="dl">"</span><span class="s2">uid</span><span class="dl">"</span> <span class="p">};</span> <span class="c1">// error</span>
<span class="kd">var</span> <span class="nx">example1</span> <span class="o">=</span> <span class="p">{</span> <span class="na">company</span><span class="p">:</span> <span class="dl">"</span><span class="s2">uber</span><span class="dl">"</span><span class="p">,</span> <span class="na">depart</span><span class="p">:</span> <span class="dl">"</span><span class="s2">dev</span><span class="dl">"</span><span class="p">,</span> <span class="na">person</span><span class="p">:</span> <span class="p">{</span> <span class="na">depart</span><span class="p">:</span> <span class="dl">"</span><span class="s2">uid</span><span class="dl">"</span> <span class="p">}</span> <span class="p">};</span>
</code></pre></div></div>

<h3 id="숫자를-문자열로-바꾸기">숫자를 문자열로 바꾸기</h3>

<ul>
  <li>숫자 앞, 뒤에 빈 문자열 ‘‘을 + 연산자로 더해주면 숫자가 문자로 자동캐스팅 됨.</li>
</ul>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">str</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="dl">""</span><span class="p">;</span>
</code></pre></div></div>

<h3 id="숫자-구분자-허용">숫자 구분자 허용</h3>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">num</span> <span class="o">=</span> <span class="mi">1</span><span class="nx">_000_000_000</span><span class="p">;</span> <span class="c1">// equals 1000000000</span>
</code></pre></div></div>

<h3 id="객체-유효성-체크---옵셔널-체이닝-연산자-">객체 유효성 체크 - 옵셔널 체이닝 연산자 ‘?’</h3>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">company</span><span class="p">:</span> <span class="p">{</span>
    <span class="na">name</span> <span class="p">:</span> <span class="dl">'</span><span class="s1">the uber creative</span><span class="dl">'</span><span class="p">,</span>
    <span class="na">addr</span> <span class="p">:</span> <span class="dl">'</span><span class="s1">nonhyeon</span><span class="dl">'</span><span class="p">,</span>
  <span class="p">}</span>
  <span class="nl">depart</span><span class="p">:</span> <span class="dl">"</span><span class="s2">dev</span><span class="dl">"</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">if</span><span class="p">(</span><span class="nx">obj</span><span class="p">.</span><span class="nx">company</span> <span class="o">&amp;&amp;</span> <span class="nx">obj</span><span class="p">.</span><span class="nx">company</span><span class="p">.</span><span class="nx">name</span><span class="p">)</span> <span class="p">{}</span> <span class="c1">//</span>
<span class="k">if</span><span class="p">(</span><span class="nx">obj</span><span class="p">.</span><span class="nx">company</span><span class="p">?.</span><span class="nx">name</span><span class="p">)</span> <span class="p">{}</span> <span class="c1">//</span>
</code></pre></div></div>

<h3 id="tdztemporary-dead-zone">TDZ(Temporary Dead Zone)</h3>

<ul>
  <li>임시 사각 지대. 호이스팅 된 변수, 함수 선언 정보 중 초기화 안된것들을 따로 저장해두는 분리된 메모리 영역.</li>
  <li>렉시컬 환경 : 현재 실행중인 코드의 스코프 안에 선언된 변수, 함수정보와 값을 보관하는 메모리 영역</li>
  <li>환경 레코드 : 현재 실행중인 코드 행의 스코프 안에 선언된 변수와 함수의 실행 환경 정보를 저장한 곳</li>
</ul>

<h3 id="함수-선언과-함수-표현의-호이스팅">함수 선언과 함수 표현의 호이스팅</h3>

<ul>
  <li>아래 두 방법 모두 표준 JS 함수 정의 방법.</li>
</ul>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">example1</span><span class="dl">"</span><span class="p">);</span>
<span class="p">};</span> <span class="c1">// 함수 표현</span>

<span class="kd">function</span> <span class="nx">b</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">conosle</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">exmaple2</span><span class="dl">"</span><span class="p">);</span>
<span class="p">}</span> <span class="c1">// 함수 선언</span>
</code></pre></div></div>

<ul>
  <li>아래의 a()는 error 발생, b()는 정상작동 이유</li>
</ul>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">a</span><span class="p">();</span>
<span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="kd">function</span> <span class="nx">a</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">a</span><span class="dl">"</span><span class="p">);</span>
<span class="p">};</span>

<span class="nx">b</span><span class="p">();</span>
<span class="kd">function</span> <span class="nx">b</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">b</span><span class="dl">"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<blockquote>
  <p>호이스팅 순서 때문.</p>
</blockquote>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="kc">undefined</span><span class="p">;</span> <span class="c1">// 1. 변수 호이스팅</span>
<span class="kd">function</span> <span class="nx">b</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">b</span><span class="dl">"</span><span class="p">);</span> <span class="c1">// 2. 함수 호이스팅</span>
<span class="p">}</span>
<span class="nx">a</span><span class="p">();</span> <span class="c1">// 3. 함수 호출 - error</span>
<span class="nx">a</span> <span class="o">=</span> <span class="kd">function</span> <span class="nx">a</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">a</span><span class="dl">"</span><span class="p">);</span> <span class="c1">// 4. 함수 정의</span>
<span class="p">};</span>
</code></pre></div></div>

<h3 id="가비지-콜렉션garbage-collection">가비지 콜렉션(Garbage Collection)</h3>

<ul>
  <li>메모리 관리 방식으로, 할당 후 사용되지 않는 메모리 공간을 일정 주기로 검사해서 회수하는 메모리 관리 방식.</li>
  <li>더이상 변수에 의해 참조되지 않는 메모리 영역을 해제하는 방식으로 GC 작동.</li>
</ul>

<h3 id="debugger-키워드로-디버깅-시작">debugger 키워드로 디버깅 시작</h3>

<ul>
  <li>debugger 키워드를 코드 특정 위치에 삽입하면, 브라우저는 코드 실행을 해당 위치에서 잠시 멈추고 내장 디버거를 활성화 시킴.</li>
</ul>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">a</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
<span class="kd">let</span> <span class="nx">b</span> <span class="o">=</span> <span class="mi">200</span><span class="p">;</span>
<span class="kd">let</span> <span class="nx">c</span> <span class="o">=</span> <span class="nx">a</span> <span class="o">+</span> <span class="nx">b</span><span class="p">;</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">c=</span><span class="dl">"</span><span class="p">,</span> <span class="nx">c</span><span class="p">);</span>

<span class="k">debugger</span><span class="p">;</span>

<span class="kd">let</span> <span class="nx">d</span> <span class="o">=</span> <span class="nx">a</span> <span class="o">-</span> <span class="nx">b</span><span class="p">;</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">d=</span><span class="dl">"</span><span class="p">,</span> <span class="nx">d</span><span class="p">);</span>
</code></pre></div></div>]]></content><author><name>mynameiskuun</name></author><category term="book-study" /><category term="practical-js" /><summary type="html"><![CDATA[폴리필(Polyfill)]]></summary></entry><entry><title type="html">알고리즘 문제풀이 - 임시반장 정하기</title><link href="http://localhost:4000/coding-test/%EC%9E%84%EC%8B%9C%EB%B0%98%EC%9E%A5-%EC%A0%95%ED%95%98%EA%B8%B0/" rel="alternate" type="text/html" title="알고리즘 문제풀이 - 임시반장 정하기" /><published>2024-01-29T00:00:00+09:00</published><updated>2024-01-29T00:00:00+09:00</updated><id>http://localhost:4000/coding-test/%EC%9E%84%EC%8B%9C%EB%B0%98%EC%9E%A5%20%EC%A0%95%ED%95%98%EA%B8%B0</id><content type="html" xml:base="http://localhost:4000/coding-test/%EC%9E%84%EC%8B%9C%EB%B0%98%EC%9E%A5-%EC%A0%95%ED%95%98%EA%B8%B0/"><![CDATA[<h2 id="알고리즘-문제풀이-연습---6">알고리즘 문제풀이 연습 - 6</h2>

<p><img src="/assets/images/temp_leader.png" alt="Alt text" />
<img src="/assets/images/temp_leader2.png" alt="Alt text" /></p>

<h3 id="제출한-답안">제출한 답안</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">answer</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
<span class="kt">int</span> <span class="n">max</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">MIN_VALUE</span><span class="o">;</span>

<span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">count</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span> <span class="c1">// 비교 기준 학생</span>
  <span class="kt">int</span> <span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
  <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">j</span><span class="o">&lt;</span><span class="n">count</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span> <span class="c1">// 비교 대상 학생</span>
    <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">k</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">k</span><span class="o">&lt;</span><span class="mi">5</span><span class="o">;</span> <span class="n">k</span><span class="o">++)</span> <span class="o">{</span> <span class="c1">// 학년</span>
      <span class="k">if</span><span class="o">(</span><span class="n">inputArray</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">k</span><span class="o">]</span> <span class="o">==</span> <span class="n">inputArray</span><span class="o">[</span><span class="n">j</span><span class="o">][</span><span class="n">k</span><span class="o">])</span> <span class="o">{</span>
        <span class="n">cnt</span><span class="o">++;</span>
        <span class="k">break</span><span class="o">;</span>
      <span class="o">}</span>
    <span class="o">}</span>
  <span class="o">}</span>

  <span class="k">if</span><span class="o">(</span><span class="n">cnt</span> <span class="o">&gt;</span> <span class="n">max</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">max</span> <span class="o">=</span> <span class="n">cnt</span><span class="o">;</span>
    <span class="n">answer</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h3 id="어려웠던-점">어려웠던 점</h3>

<ul>
  <li>
    <p>break</p>

    <ul>
      <li>두 학생을 비교해서 같은반으로 판별된 즉시 반복문을 중지하지 않으면, 다른 학년에서 같은 반으로 판별될 경우 cnt가 1번 더 증가하게됨.</li>
    </ul>
  </li>
  <li>
    <p>임시반장 후보가 여러명일 때, 가장 작은 번호 추리기</p>
    <ul>
      <li>HashSet을 사용하여 중복을 제거하려 했으나 아래의 방법으로 간단하게 해결 가능.</li>
    </ul>
  </li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span><span class="o">(</span><span class="n">cnt</span> <span class="o">&gt;</span> <span class="n">max</span><span class="o">)</span> <span class="o">{</span>
  <span class="n">max</span> <span class="o">=</span> <span class="n">cnt</span><span class="o">;</span> <span class="c1">// 동일 cnt일 경우 가장 먼저 등록된 번호(가장 작은 번호)</span>
  <span class="n">answer</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span> <span class="c1">//index</span>
<span class="o">}</span>
</code></pre></div></div>]]></content><author><name>mynameiskuun</name></author><category term="coding-test" /><category term="Algorithm" /><summary type="html"><![CDATA[알고리즘 문제풀이 연습 - 6]]></summary></entry><entry><title type="html">알고리즘 문제풀이 - 격자판 최대합 구하기</title><link href="http://localhost:4000/coding-test/%EA%B2%A9%EC%9E%90%ED%8C%90-%EC%B5%9C%EB%8C%80%ED%95%A9-%EA%B5%AC%ED%95%98%EA%B8%B0/" rel="alternate" type="text/html" title="알고리즘 문제풀이 - 격자판 최대합 구하기" /><published>2024-01-27T00:00:00+09:00</published><updated>2024-01-27T00:00:00+09:00</updated><id>http://localhost:4000/coding-test/%EA%B2%A9%EC%9E%90%ED%8C%90%20%EC%B5%9C%EB%8C%80%ED%95%A9%20%EA%B5%AC%ED%95%98%EA%B8%B0</id><content type="html" xml:base="http://localhost:4000/coding-test/%EA%B2%A9%EC%9E%90%ED%8C%90-%EC%B5%9C%EB%8C%80%ED%95%A9-%EA%B5%AC%ED%95%98%EA%B8%B0/"><![CDATA[<h2 id="알고리즘-문제풀이-연습---5">알고리즘 문제풀이 연습 - 5</h2>

<p><img src="/assets/images/bingo.png" alt="Alt text" /></p>

<h3 id="제출한-답안">제출한 답안</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">CodingTestApplication</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">solution</span><span class="o">(</span><span class="kt">int</span> <span class="n">count</span><span class="o">,</span> <span class="kt">int</span><span class="o">[][]</span> <span class="n">inputArray</span><span class="o">)</span> <span class="o">{</span>

        <span class="kt">int</span> <span class="n">temp</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">answer</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">count</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">j</span><span class="o">&lt;</span><span class="n">count</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
                <span class="n">temp</span> <span class="o">+=</span> <span class="n">inputArray</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">];</span>
            <span class="o">}</span>
            <span class="k">if</span><span class="o">(</span><span class="n">temp</span> <span class="o">&gt;</span> <span class="n">answer</span><span class="o">)</span> <span class="n">answer</span> <span class="o">=</span> <span class="n">temp</span><span class="o">;</span>
            <span class="n">temp</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">k</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">k</span><span class="o">&lt;</span><span class="n">count</span><span class="o">;</span> <span class="n">k</span><span class="o">++)</span> <span class="o">{</span>
                <span class="n">temp</span> <span class="o">+=</span> <span class="n">inputArray</span><span class="o">[</span><span class="n">k</span><span class="o">][</span><span class="n">i</span><span class="o">];</span>
            <span class="o">}</span>
            <span class="k">if</span><span class="o">(</span><span class="n">temp</span> <span class="o">&gt;</span> <span class="n">answer</span><span class="o">)</span> <span class="n">answer</span> <span class="o">=</span> <span class="n">temp</span><span class="o">;</span>
            <span class="n">temp</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">count</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">count</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">j</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">temp</span> <span class="o">+=</span> <span class="n">inputArray</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">];</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="k">if</span><span class="o">(</span><span class="n">temp</span> <span class="o">&gt;</span> <span class="n">answer</span><span class="o">)</span> <span class="n">answer</span> <span class="o">=</span> <span class="n">temp</span><span class="o">;</span>
        <span class="n">temp</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">count</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">k</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">k</span><span class="o">&lt;</span><span class="n">count</span><span class="o">;</span> <span class="n">k</span><span class="o">++)</span> <span class="o">{</span>
                <span class="k">if</span><span class="o">(</span><span class="n">i</span><span class="o">+</span><span class="n">k</span> <span class="o">==</span> <span class="n">count</span><span class="o">-</span><span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">temp</span> <span class="o">+=</span> <span class="n">inputArray</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">k</span><span class="o">];</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">if</span><span class="o">(</span><span class="n">temp</span> <span class="o">&gt;</span> <span class="n">answer</span><span class="o">)</span> <span class="n">answer</span> <span class="o">=</span> <span class="n">temp</span><span class="o">;</span>

        <span class="k">return</span> <span class="n">answer</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">){</span>
        <span class="nc">CodingTestApplication</span> <span class="n">main</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">CodingTestApplication</span><span class="o">();</span>
        <span class="nc">Scanner</span> <span class="n">in</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Scanner</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">in</span><span class="o">);</span>

        <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="n">in</span><span class="o">.</span><span class="na">nextInt</span><span class="o">();</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">inputArray</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">count</span><span class="o">][</span><span class="n">count</span><span class="o">];</span>

        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">count</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">j</span><span class="o">&lt;</span><span class="n">count</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
                <span class="n">inputArray</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">in</span><span class="o">.</span><span class="na">nextInt</span><span class="o">();</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">main</span><span class="o">.</span><span class="na">solution</span><span class="o">(</span><span class="n">count</span><span class="o">,</span> <span class="n">inputArray</span><span class="o">));</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h2 id="개선점">개선점</h2>

<ul>
  <li>문제의 난이도는 평이했으나, 코드를 좀더 간결하게 작성할 수 있었음.</li>
</ul>

<h3 id="개선점-1">개선점 1</h3>

<blockquote>
  <p>가로합, 세로합 연산 로직 통합</p>
</blockquote>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">TO</span><span class="o">-</span><span class="no">BE</span>

<span class="nf">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">count</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
    <span class="n">sum1</span> <span class="o">=</span> <span class="n">sum2</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">j</span><span class="o">&lt;</span><span class="n">count</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
        <span class="n">sum1</span> <span class="o">+=</span> <span class="n">array</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">];</span>
        <span class="n">sum2</span> <span class="o">+=</span> <span class="n">array</span><span class="o">[</span><span class="n">j</span><span class="o">][</span><span class="n">i</span><span class="o">];</span>
    <span class="o">}</span>
    <span class="n">answer</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">MAX</span><span class="o">(</span><span class="n">answer</span><span class="o">,</span> <span class="n">sum1</span><span class="o">);</span>
    <span class="n">answer</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">MAX</span><span class="o">(</span><span class="n">answer</span><span class="o">,</span> <span class="n">sum2</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<h3 id="개선점-2">개선점 2</h3>

<blockquote>
  <p>대각선 연산 로직 통합, 간결화</p>
</blockquote>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">TO</span><span class="o">-</span><span class="no">BE</span>

<span class="nf">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">count</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
    <span class="n">sum1</span> <span class="o">+=</span> <span class="n">array</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">i</span><span class="o">];</span>
    <span class="n">sum2</span> <span class="o">+=</span> <span class="n">array</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">count</span><span class="o">-</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">];</span>
<span class="o">}</span>
</code></pre></div></div>]]></content><author><name>mynameiskuun</name></author><category term="coding-test" /><category term="Algorithm" /><summary type="html"><![CDATA[알고리즘 문제풀이 연습 - 5]]></summary></entry><entry><title type="html">알고리즘 문제풀이 - 소수 뒤집기</title><link href="http://localhost:4000/coding-test/%EC%86%8C%EC%88%98-%EB%92%A4%EC%A7%91%EA%B8%B0/" rel="alternate" type="text/html" title="알고리즘 문제풀이 - 소수 뒤집기" /><published>2024-01-09T00:00:00+09:00</published><updated>2024-01-09T00:00:00+09:00</updated><id>http://localhost:4000/coding-test/%EC%86%8C%EC%88%98%20%EB%92%A4%EC%A7%91%EA%B8%B0</id><content type="html" xml:base="http://localhost:4000/coding-test/%EC%86%8C%EC%88%98-%EB%92%A4%EC%A7%91%EA%B8%B0/"><![CDATA[<h2 id="알고리즘-문제풀이-연습---4">알고리즘 문제풀이 연습 - 4</h2>

<h3><img src="/assets/images/reverse_prime.png" alt="소수 뒤집기" /></h3>

<hr />

<h3 id="제출한-답안">제출한 답안</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">isPrime</span><span class="o">(</span><span class="kt">int</span> <span class="n">num</span><span class="o">)</span> <span class="o">{</span>

        <span class="k">if</span><span class="o">(</span><span class="n">num</span><span class="o">==</span><span class="mi">1</span><span class="o">)</span> <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">2</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">num</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
             <span class="k">if</span><span class="o">(</span><span class="n">num</span> <span class="o">%</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                 <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
             <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="nf">solution</span><span class="o">(</span><span class="kt">int</span> <span class="n">count</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">input</span><span class="o">)</span> <span class="o">{</span>

        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">answer</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>

        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">count</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">input</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
            <span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
            <span class="k">while</span><span class="o">(</span><span class="n">tmp</span><span class="o">&gt;</span><span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                <span class="kt">int</span> <span class="n">t</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">%</span><span class="mi">10</span><span class="o">;</span>
                <span class="n">res</span> <span class="o">=</span> <span class="n">res</span> <span class="o">*</span> <span class="mi">10</span> <span class="o">+</span> <span class="n">t</span><span class="o">;</span>
                <span class="n">tmp</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">/</span><span class="mi">10</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="k">if</span><span class="o">(</span><span class="n">isPrime</span><span class="o">(</span><span class="n">res</span><span class="o">))</span> <span class="o">{</span>
                <span class="n">answer</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">res</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">answer</span><span class="o">;</span>
    <span class="o">}</span>
</code></pre></div></div>

<h3 id="어려웠던-점">어려웠던 점</h3>

<ul>
  <li>숫자를 어떻게 뒤집을 것인가?
    <ul>
      <li>개인적으로는 입력받은 수를 StringBuilder의 reverse() 메소드로 뒤집을 생각이었음.</li>
      <li>단순히 문자열을 뒤집는것 보다는, 위의 방법처럼 나머지와 몫을 이용해 수학적으로 접근하기.</li>
    </ul>
  </li>
</ul>

<blockquote>
  <p>t : %10 연산을 통해 가장 끝자리 수(나머지)를 추출하기 위한 변수.<br />
res : 뒤집은 문자열을 저장하기 위한 변수. t의 값이 res * 10을 통해 자릿수를 형성함. <br />
tmp : /10 연산을 통해 자릿수를 줄여나감. 반복문의 종료시점을 생성.</p>
</blockquote>]]></content><author><name>mynameiskuun</name></author><category term="coding-test" /><category term="Algorithm" /><summary type="html"><![CDATA[알고리즘 문제풀이 연습 - 4]]></summary></entry><entry><title type="html">알고리즘 문제풀이 - 소수의 판별</title><link href="http://localhost:4000/coding-test/%EC%97%90%EB%9D%BC%ED%86%A0%EC%8A%A4%ED%85%8C%EB%84%A4%EC%8A%A4%EC%9D%98_%EC%B2%B4/" rel="alternate" type="text/html" title="알고리즘 문제풀이 - 소수의 판별" /><published>2024-01-04T00:00:00+09:00</published><updated>2024-01-04T00:00:00+09:00</updated><id>http://localhost:4000/coding-test/%EC%97%90%EB%9D%BC%ED%86%A0%EC%8A%A4%ED%85%8C%EB%84%A4%EC%8A%A4%EC%9D%98_%EC%B2%B4</id><content type="html" xml:base="http://localhost:4000/coding-test/%EC%97%90%EB%9D%BC%ED%86%A0%EC%8A%A4%ED%85%8C%EB%84%A4%EC%8A%A4%EC%9D%98_%EC%B2%B4/"><![CDATA[<h2 id="알고리즘-문제풀이-연습---3">알고리즘 문제풀이 연습 - 3</h2>

<h3><img src="/assets/images/prime.png" alt="소수의 판별" /></h3>

<hr />

<h3 id="제출한-답안">제출한 답안</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span><span class="o">{</span>

    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">solution</span><span class="o">(</span><span class="kt">int</span> <span class="n">count</span><span class="o">)</span> <span class="o">{</span>

        <span class="kt">int</span> <span class="n">answer</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">array</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">count</span><span class="o">+</span><span class="mi">1</span><span class="o">];</span>
        <span class="n">array</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
        <span class="n">array</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>

        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">2</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;=</span><span class="n">count</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">2</span><span class="o">;</span> <span class="n">j</span><span class="o">&lt;=</span><span class="n">i</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
                <span class="k">if</span><span class="o">(</span> <span class="c1">// 소수 판별 ) {</span>
                    <span class="n">answer</span><span class="o">++;</span>
                    <span class="c1">// 판별된 소수 배수 val 1 처리</span>
                <span class="o">}</span>
            <span class="o">}</span>
            <span class="k">return</span> <span class="n">answer</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="c1">//main method 생략</span>
<span class="o">}</span>
</code></pre></div></div>

<h3 id="어려웠던-점">어려웠던 점</h3>

<ul>
  <li>소수 판별 어떻게?
    <ul>
      <li>2 ~ count까지의 수를 반복문을 통해 소수 여부를 판별하려 했음. 하지만 위의 로직대로라면, 2와 3은 소수이지만 내부 반복문에서 2와 3으로 나눠지기 때문에 나머지가 0으로 되어 소수가 아닌것으로 처리되는 이슈. (사전처리 3까지 하고, i = 4로 설정?)</li>
    </ul>
  </li>
</ul>

<h3 id="모범-답안">모범 답안</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>

  <span class="kd">public</span> <span class="kt">int</span> <span class="nf">solution</span><span class="o">(</span><span class="kt">int</span> <span class="n">count</span><span class="o">)</span> <span class="o">{</span>

    <span class="kt">int</span> <span class="n">answer</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="kt">int</span><span class="o">[]</span> <span class="n">array</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">count</span><span class="o">+</span><span class="mi">1</span><span class="o">];</span>

    <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">2</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;=</span><span class="n">count</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
      <span class="k">if</span><span class="o">(</span><span class="n">array</span><span class="o">[</span><span class="n">i</span><span class="o">]==</span><span class="mi">0</span><span class="o">){</span>
        <span class="n">answer</span><span class="o">++;</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="n">i</span><span class="o">;</span> <span class="n">j</span><span class="o">&lt;=</span><span class="n">count</span><span class="o">;</span> <span class="n">j</span><span class="o">=</span><span class="n">j</span><span class="o">+</span><span class="n">i</span><span class="o">)</span> <span class="o">{</span>
         <span class="n">array</span><span class="o">[</span><span class="n">j</span><span class="o">]=</span><span class="mi">1</span><span class="o">;</span>
        <span class="o">}</span>
      <span class="o">}</span>
    <span class="o">}</span>
      <span class="k">return</span> <span class="n">answer</span><span class="o">;</span>
  <span class="o">}</span>

    <span class="c1">//main method 생략</span>

<span class="o">}</span>
</code></pre></div></div>

<h3 id="주목할-포인트">주목할 포인트</h3>

<ul>
  <li>2, 3의 처리방법
    <ul>
      <li>int형 배열 생성 시 기본값은 0. 2부터 반복문을 돌리고, 바로 value = 0 검사.</li>
      <li>2, 3은 value 0이기 때문에 소수 처리 가능. 또한 배수 처리도 가능.</li>
      <li>소수 판별 로직을 하나하나 작성하지 않아도, 2, 3의 사전 처리 때문에 자연스럽게 배수처리가 가능.</li>
    </ul>
  </li>
</ul>

<h3 id="심화">심화</h3>

<ul>
  <li>위의 문제에서는 소수의 갯수만 출력하지만, 실제로 소수 그 자체를 출력하는 문제로 변형된다면?</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">function</span> <span class="nf">isPrime</span><span class="o">(</span><span class="kt">int</span> <span class="n">num</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">if</span><span class="o">(</span><span class="n">num</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span>
    <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
  <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">2</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">num</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
    <span class="k">if</span><span class="o">(</span><span class="n">num</span> <span class="o">%</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
      <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
    <span class="o">}</span>
  <span class="o">}</span>
  <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
<span class="o">}</span>

<span class="k">if</span><span class="o">(</span><span class="n">isPrime</span><span class="o">(</span><span class="kt">int</span> <span class="n">num</span><span class="o">))</span> <span class="o">{</span>
  <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">num</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<blockquote>
  <p>2 ~ n 까지의 숫자 중 어느것도 약수가 아닐때, (1과 자기 자신이 약수일 때) 해당 수는 소수가 된다.</p>
</blockquote>]]></content><author><name>mynameiskuun</name></author><category term="coding-test" /><category term="Algorithm" /><summary type="html"><![CDATA[알고리즘 문제풀이 연습 - 3]]></summary></entry><entry><title type="html">알고리즘 문제풀이 - 피보나치 수열</title><link href="http://localhost:4000/coding-test/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%AC%B8%EC%A0%9C%ED%92%80%EC%9D%B4(2)/" rel="alternate" type="text/html" title="알고리즘 문제풀이 - 피보나치 수열" /><published>2023-12-21T00:00:00+09:00</published><updated>2023-12-21T00:00:00+09:00</updated><id>http://localhost:4000/coding-test/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98%20%EB%AC%B8%EC%A0%9C%ED%92%80%EC%9D%B4(2)</id><content type="html" xml:base="http://localhost:4000/coding-test/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%AC%B8%EC%A0%9C%ED%92%80%EC%9D%B4(2)/"><![CDATA[<h2 id="알고리즘-문제풀이-연습---2">알고리즘 문제풀이 연습 - 2</h2>

<h3><img src="/assets/images/Algorithm_2.png" alt="피보나치 수열" /></h3>

<hr />

<h3 id="제출한-답안">제출한 답안</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">solution</span><span class="o">(</span><span class="kt">int</span> <span class="n">count</span><span class="o">)</span> <span class="o">{</span>

        <span class="kt">int</span><span class="o">[]</span> <span class="n">answer</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">count</span><span class="o">];</span>
        <span class="n">answer</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
        <span class="n">answer</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>

        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">2</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">count</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">answer</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">answer</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">2</span><span class="o">]</span> <span class="o">+</span> <span class="n">answer</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">];</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">answer</span><span class="o">;</span>
    <span class="o">}</span>
</code></pre></div></div>

<h2 id="문제-해결-중-학습한-부분">문제 해결 중 학습한 부분.</h2>

<h3 id="재귀함수">재귀함수</h3>

<ul>
  <li>
    <p>재귀란?</p>

    <blockquote>
      <p>컴퓨터 과학에서, 자신을 정의할 때 자기 자신을 재참조 하는 방법.</p>
    </blockquote>
  </li>
  <li>
    <p>재귀함수란?</p>
    <blockquote>
      <p>재귀의 설명 그대로, 함수에서 자기 자신을 다시 호출해 작업을 수행하는 방식.
주로 반복문을 구현할 때 사용한다.</p>
    </blockquote>
  </li>
</ul>

<hr />

<h3 id="재귀함수를-이용한-피보나치-수열-구현">재귀함수를 이용한 피보나치 수열 구현</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kt">int</span> <span class="nf">solution</span><span class="o">(</span><span class="kt">int</span> <span class="n">count</span><span class="o">)</span> <span class="o">{</span>

    <span class="k">if</span><span class="o">(</span><span class="n">count</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="mi">1</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="nf">solution</span><span class="o">(</span><span class="n">i</span><span class="o">-</span><span class="mi">2</span><span class="o">)</span> <span class="o">+</span> <span class="n">solution</span><span class="o">(</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<hr />

<h3 id="재귀함수의-장단점">재귀함수의 장단점</h3>

<h4 id="장점">장점</h4>

<ul>
  <li>가독성이 향상된다.</li>
  <li>변수 사용을 줄여줌으로서, 변경 가능성(mutable state)을 최소화 시켜 프로그램의 안정성을 향상시킨다.</li>
</ul>

<h4 id="단점">단점</h4>

<ul>
  <li>매개변수, 지역변수, 리턴 값, 함수 종료 후 복귀지점이 스택 메모리에 저장되기 때문에, 메모리 사용량이 높다.</li>
  <li>그렇기 때문에 일반적으로 반복문 보다 성능이 낮다.</li>
</ul>

<hr />

<h3 id="재귀함수-단점-보완을-위한-방법">재귀함수 단점 보완을 위한 방법</h3>

<h4 id="메모이제이션">메모이제이션</h4>

<blockquote>
  <p>재귀함수의 단점을 보완하기 위한 방법으로 값비싼 함수 호출의 결과를 캐싱하고, 동일한 입력이 발생할 때 함수를 호출하지 않고 캐싱된 결과를 반환하는 기술.</p>
</blockquote>

<hr />

<h3 id="메모이제이션을-사용해-구현한-피보나치-수열">메모이제이션을 사용해 구현한 피보나치 수열</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">memo</span><span class="o">;</span>

<span class="kd">public</span> <span class="kt">int</span> <span class="nf">solution</span><span class="o">(</span><span class="kt">int</span> <span class="n">count</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span><span class="o">(</span><span class="n">memo</span><span class="o">[</span><span class="n">count</span><span class="o">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">memo</span><span class="o">[</span><span class="n">count</span><span class="o">];</span>
    <span class="o">}</span>
    <span class="k">if</span><span class="o">(</span><span class="n">count</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="mi">1</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">memo</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">solution</span><span class="o">(</span><span class="n">count</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">+</span> <span class="n">solution</span><span class="o">(</span><span class="n">count</span> <span class="o">-</span> <span class="mi">2</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<ul>
  <li>기존의 로직이라면, 캐싱된 값이 없기 때문에 콜스택에 count만큼 지역변수, 매개변수, 반환주소 등이 쌓이고, count의 마지막 부분에 가서야 모든 작업이 수행됨.</li>
  <li>메모이제이션을 사용할 경우, static 변수에 한번 연산된 값을 저장하게 됨. 이 경우, 한번 연산된 값은 이후 재귀함수를 통해 재연산이 불필요.</li>
</ul>

<blockquote>
  <p>핵심 : 한번 연산된 값을 저장해서, 이후 동일 작업이 호출될 때 재연산을 하는게 아닌 저장된 값을 반환한다.</p>
</blockquote>]]></content><author><name>mynameiskuun</name></author><category term="coding-test" /><category term="Algorithm" /><summary type="html"><![CDATA[알고리즘 문제풀이 연습 - 2]]></summary></entry></feed>